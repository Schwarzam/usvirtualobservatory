/*
* File: app/view/MinMaxSliderContainer.js
* Date: Thu Jan 26 2012 11:26:47 GMT-0500 (Eastern Standard Time)
*
* This file was generated by Ext Designer version 1.2.2.
* http://www.sencha.com/products/designer/
*
* This file will be generated the first time you export.
*
* You should implement event handling and custom methods in this
* class.
*/

Ext.require('Mvp.util.Coords');
Ext.require('Mvp.util.Util');

Ext.define('Mvpc.view.MinMaxSliderContainer', {
    extend: 'Mvpc.view.ui.MinMaxSliderContainer',
    alias: 'widget.minmaxsliderContainer',

    initComponent: function () {
        var me = this;
        me.callParent(arguments);
    },

    constructor: function (config) {
        this.callParent(arguments);

        Ext.apply(this, config);
        this.store = Mvp.util.Util.decimalHistogramToStore(this.hist.hist);
        this.zoomable = false;

        this.histogramContainer = this.getComponent('histogramContainer');
        this.sliderContainer = this.getComponent('sliderContainer');

        this.zoomCheckbox = Ext.create('Ext.form.field.Checkbox', {
            fieldLabel: 'Zoom to range',
            checked: this.zoomable
        });
        this.zoomCheckbox.on('change', this.zoomChange, this);
        //this.add(this.zoomCheckbox);
        this.decimals = (this.maxValue - this.minValue) ? this.discrete ? 0 : Math.max(Math.floor(-Math.log(this.increment) / Math.LN10), 2) : 4;
        // calculate a more appropriate decimal precision relative to magnitude of the range

        this.valueSlider = Ext.create('Ext.slider.Multi', {
            itemId: 'valueSlider',
            minValue: this.minValue,
            maxValue: this.maxValue,
            values: [this.minValue, this.maxValue],
            width: 231,
            margin: '0 0 0 5',
            decimalPrecision: this.discrete ? 0 : false,
            tipText: function (thumb) {
                var displayFn = thumb.slider.scope.displayFn;
                return displayFn ? displayFn(thumb.value) : Ext.Number.toFixed(thumb.value, thumb.slider.scope.decimals); ;
            },
            scope: this
        });
        this.sliderContainer.add(this.valueSlider);

        this.minmaxContainer = this.getComponent('minmaxContainer');
        this.minBox = this.minmaxContainer.getComponent('minBox');
        this.maxBox = this.minmaxContainer.getComponent('maxBox');
        this.setMin(this.minValue);     // avoid setValues in constructor so we don't fire events
        this.setMax(this.maxValue);

        this.minBox.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.minmaxChanged();
            }
        }, this);
        this.maxBox.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.minmaxChanged();
            }
        }, this);
        this.minmaxContainer.getComponent('resetButton').disable();
        this.minmaxContainer.getComponent('resetButton').on('click', this.reset, this);
        this.valueSlider.addListener('changecomplete', this.sliderChanged, this);

        if (this.ignoreValue !== undefined) {
            var cb = {
                xtype: 'label',
                text: 'The value (' + this.ignoreValue + ') is ignored by this filter',
                margin: '0 0 0 7'
            };
            this.add(cb);
        }
        this.on('render', this.configHistogram, this);
    },

    configHistogram: function () {
        if (this.histogram) this.histogramContainer.removeAll();
        this.histogram = {
            xtype: 'chart',
            theme: 'Blue',
            height: 70,
            width: 260,
            store: this.store,
            axes: [{
                minimum: 0,
                maximum: this.hist.max,
                position: 'left',
                hidden: true,      // need min/max but don't want to show values, just ratios
                type: 'Numeric',
                fields: ['count']
            }, {
                minimum: this.minValue,
                maximum: this.maxValue,
                majorTickSteps: 0,
                minorTickSteps: 0,
                position: 'bottom',
                fields: ['key'],
                type: 'Numeric',
                label: { xtype: 'label', text: '' }
            }],
            series: [{
                type: 'column',
                xField: 'key',
                yField: 'count',
                axis: 'left',
                gutter: 1.0,   // default spacing is so large the lines don't display
                xPadding: 10   // makes room for the leftmost tick label
            }]
        };
        this.histogramContainer.add(this.histogram);
    },

    zoomChange: function (obj, val) {
        this.zoomable = val;
        this.configHistogram();
    },

    minmaxChanged: function () {
        var min = this.minBox.getValue(),
            max = this.maxBox.getValue(),
            minDeg = (this.readFn) ? this.readFn(min) : Number(min),
            maxDeg = (this.readFn) ? this.readFn(max) : Number(max);
        if ((minDeg !== undefined) && (maxDeg !== undefined) && (minDeg !== '') && (maxDeg !== '')) this.setValues(minDeg, maxDeg);
    },

    sliderChanged: function () {
        var vals = this.valueSlider.getValues();
        this.setValues(vals[0], vals[1]);
    },

    setValues: function (min, max) {
        var prevMin = this.min;
        var prevMax = this.max;
        if (!this.setMin(min) || !this.setMax(max)) {
            this.setMin(prevMin);
            this.setMax(prevMax);
            return;
        }
        this.minmaxContainer.getComponent('resetButton').enable();
        this.fireEvent('rangeChanged', this.facetName, this.getValues());
        if ((min == this.minValue) && (max == this.maxValue)) {
            this.minmaxContainer.getComponent('resetButton').disable();
            this.fireEvent('filterRemoved', this.facetName);
        }
    },

    setMin: function (min) {
        var rounded = Ext.Number.toFixed(min, this.decimals);
        var diff = 1, i = this.decimals;
        while (i--) diff /= 10;
        this.min = ((rounded - this.minValue) < diff) ? this.minValue : Math.max(rounded, this.minValue);
        // when the rounded value is within the decimal precision of the boundary, use the boundary
        if (min > this.max) this.min = this.max;
        var s = this.displayFn ? this.displayFn(this.min) : this.min;
        if (s === '') return false;
        this.minBox.setValue(s);
        this.valueSlider.setValue(0, this.min);
        return true;
    },

    setMax: function (max, fireEvent) {
        var rounded = Ext.Number.toFixed(max, this.decimals);
        var diff = 1, i = this.decimals;
        while (i--) diff /= 10;
        this.max = ((this.maxValue - rounded) < diff) ? this.maxValue : Math.min(rounded, this.maxValue);
        // when the rounded value is within the decimal precision of the boundary, use the boundary
        if (max < this.min) this.max = this.min;
        var s = this.displayFn ? this.displayFn(this.max) : this.max;
        if (s === '') return false;
        this.maxBox.setValue(s);
        this.valueSlider.setValue(1, this.max);
        return true;
    },

    getMin: function () {
        return this.min;
    },

    getMax: function () {
        return this.max
    },

    getValues: function () {
        return [this.min, this.max];
    },

    reset: function () {
        this.setValues(this.minValue, this.maxValue);
    }
});
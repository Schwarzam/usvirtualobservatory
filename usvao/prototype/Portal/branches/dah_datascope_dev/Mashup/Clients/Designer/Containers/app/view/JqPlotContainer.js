/*
 * File: app/view/JqPlotContainer.js
 * Date: Wed Sep 05 2012 15:31:15 GMT-0400 (Eastern Daylight Time)
 *
 * This file was generated by Ext Designer version 1.2.3.
 * http://www.sencha.com/products/designer/
 *
 * This file will be generated the first time you export.
 *
 * You should implement event handling and custom methods in this
 * class.
 */

/*
    Class variables (except some components)
    color - base color from Astroview
    facets - dictionary of facets
        chartType - Numeric/Discrete
        increment - calculated (max - min) / 1000
        index - index into the full facet array
        isDate/isMjd - columns config info
        max/minValue - extrema for the facet
        niceName - columns config info with a human-readable facet title
        unit - units value
    plot - the jquery plot
    prevAxes - store the zoom level so the class can restore the zoom after changing selection
    rangeContainer - the fieldset containing all of the range gui
    rangeTopContainer - holds the minmaxSliderContainers, placeholder to remove the minmaxContainers without losing the place
    selectedArea - the axes endpoints from the last selection/zoom move, or the cursor position from a poke selection
    unselected - the unselected records
    selection - the selected records
    seriesContainer - the fieldset containing all of the series gui
    x/yField - the column name
    x/y/min/max - the current zoomed-in bounds of the plot
*/

Ext.define('Mvpc.view.JqPlotContainer', {
    extend: 'Mvpc.view.ui.JqPlotContainer',


    statics: {
        calculateFudge: function (min, max) {
            // calculate a value to pad the edges of the plot container so that endpoints can be seen/selected
            if (min > max) {
                var temp = min;
                min = max;
                max = temp;
            }
            var range = max - min,
                avg = min + (range / 2),
                val = Math.log(avg) / Math.LN10;
        
            if (val < 0) {  // large bonus for very small numbers
                return .02;
            } else if ((val < 1) || (val > 3)) {    // medium bonus for small or very large numbers
                return .01;
            } else if (val < 1.5) { // small bonuses for everything else
                return .01 - (val - 1) / 100;
            } else if (val < 2) {
                return .0015
            }
            return .001;
        }
    },
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },

    constructor: function (config) {
        this.callParent(arguments);
        this.store = config.store;
        this.facets = config.facets;
        delete config.facets;

        this.app = window.app;
        var em = this.app.getEventManager();
        em.addListener('APP.context.records.selected', this.conditionalDraw, this);
        em.addListener('APP.context.records.filtered', this.conditionalDraw, this);
        em.addListener('APP.context.color.changed', this.onColorChanged, this);
        this.addEvents('APP.context.records.selected');
        
        var facetData = [];
        this.facetLookup = {};
        this.numericFacets = [];
        for (var i in this.facets) {
            var facet = this.facets[i];
            var text = facet.niceName || i;
            if (facet.chartType == 'Numeric') {
                this.numericFacets.push({ title: text, unit: facet.unit, index: facet.index, key: i });
                facetData.push({ displayField: text, valueField: i });
                this.facetLookup[i] = text;
            }
        }

        var facetStore = Ext.create('Ext.data.Store', {
            fields: ['displayField', 'valueField'],
            data: facetData
        });
        
        this.configPanel = this.getComponent('configPanel');
        this.seriesPanel = this.configPanel.getComponent('seriesContainer');
        this.chartContainer = this.getComponent('chartContainer').getComponent('chartContainer');
        
        this.xComboBox = Ext.create('Ext.form.field.ComboBox', {
            store: facetStore,
            displayField: 'displayField',
            valueField: 'valueField',
            matchFieldWidth: false,
            width: 130,
            labelWidth: 10,
            fieldLabel: 'X'
        });
        this.yComboBox = Ext.create('Ext.form.field.ComboBox', {
            store: facetStore,
            displayField: 'displayField',
            valueField: 'valueField',
            matchFieldWidth: false,
            width: 130,
            labelWidth: 10,
            fieldLabel: 'Y'
        });

        var container = Ext.create('Ext.container.Container', {
            items: [this.xComboBox, this.yComboBox],
            layout: 'hbox'
        });
        this.seriesPanel.add([container]);

        this.xComboBox.setValue(this.numericFacets[0].key);
        this.yComboBox.setValue(this.numericFacets[1].key);
        
        if (this.color = this.controller.getColor()) this.color = '#' + this.color;

        this.rangeContainer = this.configPanel.getComponent('rangeContainer');  // will be populated with MinMaxSliderContainers during initial draw()
        this.zoomButton = Ext.create('Ext.button.Button', {
            text: 'Zoom',
            itemId: 'zoomButton',
            margins: '0 10 0 91',
            flex: 0
        });
        this.zoomButton.addListener('click', this.zoom, this);
        this.resetZoomButton = Ext.create('Ext.button.Button', {
            text: 'Reset Zoom',
            itemId: 'resetZoomButton',
            flex: 0
        });
        this.resetZoomButton.addListener('click', this.resetZoom, this);
        this.rangeButtonsContainer = Ext.create('Ext.container.Container', {
            layout: 'hbox',
            flex: 0,
            items: [this.zoomButton, this.resetZoomButton]
        });
        this.rangeTopContainer = Ext.create('Ext.container.Container', {});
        this.rangeContainer.add([this.rangeTopContainer, this.rangeButtonsContainer]);

        this.xLog = false;
        this.yLog = false;
        this.on('destroy', function () {
            if (this.plot) this.plot.destroy();
        }, this);
    },

    setRangeContainers: function () {
        // rebuilds the two MinMaxSliderContainers
        // the calling function is responsible for maintaining x/yField so that this function
        // can be used after changing the fields or to reset with the existing fields
        this.rangeTopContainer.removeAll();
        this.setPlotExtrema(this.xField, this.yField);

        this.xMinMaxContainer = Ext.create('Mvpc.view.MinMaxSliderContainer', this.facets[this.xField]);
        this.yMinMaxContainer = Ext.create('Mvpc.view.MinMaxSliderContainer', this.facets[this.yField]);

        this.xmax = this.xMinMaxContainer.getMax();
        this.xmin = this.xMinMaxContainer.getMin();
        this.ymax = this.yMinMaxContainer.getMax();
        this.ymin = this.yMinMaxContainer.getMin();

        this.xLogCheckbox = Ext.create('Ext.form.field.Checkbox', {
            'boxLabel': 'Use log scale',
            checked: this.xLog
        });
        this.xLogCheckbox.addListener('change', this.changeLogAxis, this);

        this.yLogCheckbox = Ext.create('Ext.form.field.Checkbox', {
            'boxLabel': 'Use log scale',
            checked: this.yLog
        });
        this.yLogCheckbox.addListener('change', this.changeLogAxis, this);

        var hrContainer = { xtype: 'container', html: '<hr />' },
            hrContainer2 = { xtype: 'container', html: '<hr /> <br />' };
        
        this.xRangeContainer = Ext.create('Ext.container.Container', {
            items: [{ xtype: 'label', text: 'X' }, this.xMinMaxContainer],
            layout: 'hbox',
            align: 'top'
        });
        this.yRangeContainer = Ext.create('Ext.container.Container', {
            items: [{ xtype: 'label', text: 'Y' }, this.yMinMaxContainer],
            layout: 'hbox',
            align: 'top',
            margin: '10 0 0 0'
        });
        this.rangeTopContainer.add([this.xRangeContainer, this.xLogCheckbox, hrContainer, this.yRangeContainer, this.yLogCheckbox, hrContainer2]);
        this.checkLog();
    },

    onColorChanged: function (event) {   // matches the Astroview color
        if (event.context.uid !== this.controller.uid) return;  // keep the chart and the grid control tethered correctly
        this.color = '#' + event.context.getColor();
        var bounds = { xaxis: { min: this.xmin, max: this.xmax }, yaxis: { min: this.ymin, max: this.ymax } };
        this.configPlot({ selectedArea: bounds, keepBounds: true, zooming: true });
    },

    checkLog: function () {
        // checks whether log scales are legal and adjusts the checkbox accordingly
        if ((this.xmin <= 0) || (this.xmax <= 0)) {
            this.xLogCheckbox.disable();
            this.xLogCheckbox.setValue(false);
        } else {
            this.xLogCheckbox.enable();
        }

        if ((this.ymin <= 0) || (this.ymax <= 0)) {
            this.yLogCheckbox.disable();
            this.yLogCheckbox.setValue(false);
        } else {
            this.yLogCheckbox.enable();
        }
    },

    zoom: function () {
        // handles a zoom triggered from the config panel
        var xVals = this.xMinMaxContainer.getValues(),
            yVals = this.yMinMaxContainer.getValues();

        this.xmin = xVals[0]; this.xmax = xVals[1];
        this.ymin = yVals[0]; this.ymax = yVals[1];
        this.prevAxes = {
            // store zooming information, will need this to restore zoom level after a selection from off the canvas
            xaxis: { min: this.xmin, max: this.xmax },
            yaxis: { min: this.ymin, max: this.ymax }
        };
        this.pinchSliders();
        this.configPlot();
        this.checkLog();
    },

    resetZoom: function () {
        // reset zoom from the range container
        this.plot.resetZoom();
        this.prevAxes = undefined;
        this.setRangeContainers();
        var axes = this.plot.axes;
        this.xmin = this.xMinMaxContainer.getMin();
        this.xmax = this.xMinMaxContainer.getMax();
        this.ymin = this.yMinMaxContainer.getMin();
        this.ymax = this.yMinMaxContainer.getMax();
        this.configPlot();
        this.checkLog();
    },

    setPlotExtrema: function (xField, yField) {
        // pads the actual min and max boundaries
        // MinMaxSliderContainer knows to do something special with expandedMin/Max
        var xFacet = this.facets[xField], yFacet = this.facets[yField];
        var xmax = xFacet.maxValue, xmin = xFacet.minValue,
            ymax = yFacet.maxValue, ymin = yFacet.minValue,
            xFudge = Mvpc.view.JqPlotContainer.calculateFudge(xmin, xmax),
            yFudge = Mvpc.view.JqPlotContainer.calculateFudge(ymin, ymax),
            xRange = xmax - xmin, yRange = ymax - ymin,
            xFacet = this.facets[xField], yFacet = this.facets[yField];
        xFacet.expandedMax = ((Math.abs(xmax) < .1) && (xRange < 10)) ? 0.1 : xmax * (1 + xFudge);
        xFacet.expandedMin = ((Math.abs(xmin) < .1) && (xRange < 10)) ? -0.1 : xmin * (1 - xFudge);
        yFacet.expandedMax = ((Math.abs(ymax) < .1) && (yRange < 10)) ? 0.1 : ymax * (1 + yFudge);
        yFacet.expandedMin = ((Math.abs(ymin) < .1) && (yRange < 10)) ? -0.1 : ymin * (1 - yFudge);
    },

    init: function () {
        // need a separate function from the constructor to initialize the canvas after it is created in the DOM
        this.xField = this.xComboBox.getValue();
        this.yField = this.yComboBox.getValue();
        this.setRangeContainers();
        this.getSelection();
        this.configPlot();
        this.addListener('resize', this.resize, this);
        this.configPanel.on({
            collapse: this.resize,
            expand: this.resize,
            scope: this
        });

        var me = this;
        var cid = this.chartContainer.getId();
        $('#' + cid).bind('setselection', function (e, selectedArea) { me.setSelection({ selectedArea: selectedArea }); }); // fired when the canvas has a cursor mouseup event
        $('#' + cid).bind('zoomtrigger', function (e, axes) { me.externalZoom({ axes: axes }); });   // fired when the canvas zooms
        $('#' + cid).bind('saveZoom', function (e, options) { Ext.apply(me, options); });   // used to remember the zoom state when a grid object is selected

        this.xComboBox.on('change', this.axisChange, this);
        this.yComboBox.on('change', this.axisChange, this);

        this.prevAxes = { xaxis: { min: this.xmin, max: this.xmax }, yaxis: { min: this.ymin, max: this.ymax } };
        this.checkLog();
    },

    axisChange: function () {
        // changes an axis and resets the bounds
        var xField = this.xComboBox.getValue(),
            yField = this.yComboBox.getValue();
        if ((xField == this.xField) && (yField == this.yField)) return;
        this.xField = xField;
        this.yField = yField;
        this.setRangeContainers();
        this.setSelection();    // just calling configPlot doesn't draw points until there's a selection made... no idea
    },

    resize: function () {
        // use this to handle any generic event that should redraw the plot without changing the bounds
        // this way you don't need a different function for however many arguments the event passes
        this.configPlot();
    },

    conditionalDraw: function (event) {
        // used by the event manager to decide whether to respond to the event
        if ((event.context.uid == this.controller.uid) && (event.sender != this)) {
            this.getSelection();
            this.configPlot();
        }
    },

    changeLogAxis: function () {
        // respond to (un)checking the log scale checkbox
        this.xLog = this.xLogCheckbox.getValue();
        this.yLog = this.yLogCheckbox.getValue();
        this.configPlot();
    },

    setSelection: function (config) {
        // calculate arrays of what is (un)selected
        this.selectedArea = config && config.selectedArea;
        this.unselected = [];
        this.selection = [];
        if (this.store.backingStore.getAt(0).get('_selected_') === undefined) return;   // skip models that don't have a selected column
        if (this.selectedArea) {
            var add = this.selectedArea.additive,
                xfudge = (this.xmax - this.xmin) / 100,
                yfudge = (this.ymax - this.ymin) / 100,
                xmax = add ? this.selectedArea.x + xfudge : this.selectedArea.xaxis.max,    // true: the bounds of a square around the cursor in which we will toggle selection status
                xmin = add ? this.selectedArea.x - xfudge : this.selectedArea.xaxis.min,    // false: the bounds of the box the user drew
                ymax = add ? this.selectedArea.y + yfudge : this.selectedArea.yaxis.max,
                ymin = add ? this.selectedArea.y - yfudge : this.selectedArea.yaxis.min;
        }
        this.store.backingStore.each(function (record) {
            var xVal = record.get(this.xField),
                yVal = record.get(this.yField),
                hasSel = record.get('_selected_');
            if (this.selectedArea) {
                sel = ((xVal <= xmax) && (xVal >= xmin) && (yVal <= ymax) && (yVal >= ymin));
                (add) ? record.set('_selected_', sel ? !hasSel : hasSel) : record.set('_selected_', sel);   // for additive (poke) selection, toggle the selection state, otherwise (box selection) turn it on iff it is inside the box
            }
            record.get('_selected_') ? this.selection.push([xVal, yVal]) : this.unselected.push([xVal, yVal]);
        }, this);

        var task = new Ext.util.DelayedTask(function () {
            this.fireEvent('APP.context.records.selected', {          // but ignore this event later by checking the sender
                type: 'APP.context.records.selected',
                context: this.controller,
                sender: this
            });
        }, this);
        task.delay(20);
        this.configPlot();
    },

    getSelection: function () {
        // retrieve the current state of store and its selection without firing events
        this.selection = [];
        this.unselected = [];
        this.store.backingStore.each(function (record) {
            var xVal = record.get(this.xField),
                yVal = record.get(this.yField),
                hasSel = record.get('_selected_');
            hasSel ? this.selection.push([xVal, yVal]) : this.unselected.push([xVal, yVal]);
        }, this);
    },

    externalZoom: function (config) {
        // respond to a zoom event from jqplot
        this.prevAxes = {
            xaxis: { min: this.xmin, max: this.xmax },
            yaxis: { min: this.ymin, max: this.ymax }
        }
        var x = config.axes.xaxis,
            y = config.axes.yaxis;
        this.xmin = x.min;
        this.xmax = x.max;
        this.ymin = y.min;
        this.ymax = y.max;
        this.pinchSliders();
        this.checkLog();
    },

    pinchSliders: function () {
        // pinch the sliders to the given range
        var xSlider = this.xMinMaxContainer.valueSlider,
            ySlider = this.yMinMaxContainer.valueSlider;
        xSlider.setMaxValue(this.xmax);
        xSlider.setMinValue(this.xmin);
        xSlider.setValue(0, this.xmin, false);
        xSlider.setValue(1, this.xmax, false);
        
        ySlider.setMaxValue(this.ymax);
        ySlider.setMinValue(this.ymin);
        ySlider.setValue(0, this.ymin, false);
        ySlider.setValue(1, this.ymax, false);

        this.xMinMaxContainer.setValues(this.xmin, this.xmax);
        this.yMinMaxContainer.setValues(this.ymin, this.ymax);
    },

    configPlot: function () {
        // create a plot object based on the instance variables
        if (this.plot) this.plot.destroy();
        this.plotData = [];
        var markerSize = 7;
        var seriesConfig = [],
            seriesColors = [];
        if (this.unselected.length) {    // jqplot requires the first array to be non-empty, this covers the case where everything is selected
            this.plotData.push(this.unselected);
            seriesConfig.push({
                label: 'Unselected',
                neighborThreshold: 1,
                showLine: false,
                markerOptions: {
                    size: markerSize
                }
            });
            seriesColors.push(this.color || '#4BB2C5'); // have a default plot color if AstroView isn't present
        }
        this.plotData.push(this.selection);
        seriesConfig.push({
            label: 'Selected',
            neighborThreshold: 1,
            showLine: false,
            markerOptions: {
                size: markerSize,
                shadow: false
            }
        });
        if (this.color) {
            var colorObj = Ext.draw.Color.fromString(this.color);
            var selectedColor = '0x' + colorObj.getLighter(.3).toString().substr(1);
            seriesColors.push(selectedColor.replace('0x', '#'));
        }
        else {
            seriesColors.push('#EAA228');
        }
        var xRenderer, yRenderer;
        if (this.xMinMaxContainer.isDate) {
            xRenderer = $.jqplot.DateAxisRenderer;
        } else if (this.xLog) {
            xRenderer = $.jqplot.LogAxisRenderer
        }
        if (this.yMinMaxContainer.isDate) {
            yRenderer = $.jqplot.DateAxisRenderer;
        } else if (this.yLog) {
            yRenderer = $.jqplot.LogAxisRenderer
        }
        var xRange = this.prevAxes ? (this.prevAxes.xaxis.max - this.prevAxes.xaxis.min) : (this.xmax - this.xmin),
            yRange = this.prevAxes ? (this.prevAxes.yaxis.max - this.prevAxes.yaxis.min) : (this.ymax - this.ymin),
            xLog = Math.ceil(-Math.log(xRange) / Math.LN10), yLog = Math.ceil(-Math.log(yRange) / Math.LN10);
        var xDecimals = Math.max(xLog, 3), yDecimals = Math.max(yLog, 3);

        var nTicks = 6;
        var options = {
            title: false,
            series: seriesConfig,
            seriesColors: seriesColors || $.jqplot.config.defaultColors,
            axes: {
                xaxis: {
                    renderer: xRenderer,
                    label: this.facetLookup[this.xField],
                    labelRenderer: $.jqplot.CanvasAxisLabelRenderer,    // lets us spin the label and change fonts
                    tickRenderer: $.jqplot.CanvasAxisTickRenderer,  //lets us spin the axis ticks and change fonts
                    tickOptions: {
                        angle: -30,
                        formatString: this.xMinMaxContainer.isDate ? '%m-%Y' : '%.' + xDecimals + 'f',
                    },
                    //numberTicks: nTicks,
                    min: this.xmin,
                    max: this.xmax
                },
                yaxis: {
                    renderer: yRenderer,
                    label: this.facetLookup[this.yField],
                    labelRenderer: $.jqplot.CanvasAxisLabelRenderer,
                    tickRenderer: $.jqplot.CanvasAxisTickRenderer,
                    tickOptions: {
                        formatString: this.yMinMaxContainer.isDate ? '%m-%Y' : '%.' + yDecimals + 'f',
                        base: 10
                    },
                    //numberTicks: nTicks,
                    min: this.ymin,
                    max: this.ymax
                }
            },
            cursor: {
                show: true,
                zoom: true,
                dblClickReset: false,
                looseZoom: false
            },
            highlighter: {
                show: true,
                showTooltip: false
            }
        }
        if (this.chartContainer && !this.chartContainer.isDestroyed) this.plot = $.jqplot(this.chartContainer.getId(), this.plotData, options);
    }
});
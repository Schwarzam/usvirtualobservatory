/*
* File: app/view/MinMaxSliderContainer.js
* Date: Thu Jan 26 2012 11:26:47 GMT-0500 (Eastern Standard Time)
*
* This file was generated by Ext Designer version 1.2.2.
* http://www.sencha.com/products/designer/
*
* This file will be generated the first time you export.
*
* You should implement event handling and custom methods in this
* class.
*/

Ext.define('Mvpc.view.MinMaxSliderContainer', {
    extend: 'Mvpc.view.ui.MinMaxSliderContainer',
    alias: 'widget.minmaxsliderContainer',
    requires: ['Mvp.util.Coords', 'Mvp.util.Util', 'Ext.slider.Multi', 'Ext.data.JsonStore', 'Ext.data.reader.Json', 'Mvp.util.Constants'],

    initComponent: function () {
        var me = this;
        me.callParent(arguments);
    },

    constructor: function (config) {
        delete config.listeners;
        Ext.apply(this, config);
        this.callParent(arguments);
        this.origMinValue = this.minValue;
        this.origMaxValue = this.maxValue;
        if (this.expandedMin !== undefined) this.minValue = this.expandedMin;
        if (this.expandedMax !== undefined) this.maxValue = this.expandedMax;

        this.sliderContainer = this.getComponent('sliderContainer');
        this.decimals = (this.maxValue - this.minValue) ? this.discrete ? 0 : Math.max(Math.floor(-Math.log(this.increment) / Math.LN10), 2) : 4;
        // calculate a more appropriate decimal precision relative to magnitude of the range

        this.sliderMin = this.minValue;
        this.sliderMax = this.maxValue;
        this.valueSlider = Ext.create('Ext.slider.Multi', {
            itemId: 'valueSlider',
            minValue: this.sliderMin,
            maxValue: this.sliderMax,
            values: [this.minValue, this.maxValue],
            width: 231,
            margin: '0 0 3 5',
            decimalPrecision: this.discrete ? 0 : false,
            useTips: {
                xtype: 'slidertip',
                position: 'right',
                padding: 0,
                //align: 'b-t?',
                //offsets: '[0, -3]',
                getText: function (thumb) {
                    var displayFn = thumb.slider.scope.displayFn;
                    return displayFn ? displayFn(thumb.value) : Ext.Number.toFixed(thumb.value, thumb.slider.scope.decimals);
                }
            },
            scope: this
        });
        this.sliderContainer.add(this.valueSlider);

        this.minmaxContainer = this.getComponent('minmaxContainer');
        this.minBox = this.minmaxContainer.getComponent('minBox');
        this.maxBox = this.minmaxContainer.getComponent('maxBox');
        this.setMin(this.minValue);
        this.setMax(this.maxValue);

        this.minBox.on({
            'specialkey': function (f, e) { if (e.getKey() == e.ENTER) this.minmaxChanged(); },
            'blur': this.minmaxChanged,
            scope: this
        });
        this.maxBox.on({
            'specialkey': function (f, e) { if (e.getKey() == e.ENTER) this.minmaxChanged(); },
            'blur': this.minmaxChanged,
            scope: this
        });
        this.valueSlider.on({
            changecomplete: this.sliderChanged,
            scope: this
        });
    },

    minmaxChanged: function () {
        var min = this.minBox.getValue(),
            max = this.maxBox.getValue(),
            minDeg = (this.readFn) ? this.readFn(min) : Number(min),
            maxDeg = (this.readFn) ? this.readFn(max) : Number(max);
        if (this.readFn && this.displayFn) {
            if ((minDeg == this.readFn(this.displayMin)) && (maxDeg == this.readFn(this.displayMax))) return false;
        }
        if ((minDeg !== undefined) && (maxDeg !== undefined) && (minDeg !== '') && (maxDeg !== '')) this.setValues(minDeg, maxDeg, true);
    },

    sliderChanged: function () {
        this.ignoreChange = true;
        var vals = this.valueSlider.getValues();
        if (!this.setValues(vals[0], vals[1])) this.fireEvent('slideFailed');
        this.ignoreChange = false;
    },

    setValues: function (min, max, exact) {
        if ((min == this.min) && (max == this.max)) return false;
        var prevMin = this.min;
        var prevMax = this.max;
        if (!this.setMin(min, exact) || !this.setMax(max, exact)) {
            this.setMin(prevMin, exact);
            this.setMax(prevMax, exact);
            return;
        }
        this.fireEvent('rangeChanged', this.getValues());
    },

    setMin: function (min, exact) {
        if (min < this.minValue) this.minValue = min;
        if (exact) {
            this.min = Math.max(min, this.minValue);
        } else {
            var rounded = Ext.Number.toFixed(min, this.decimals);
            var diff = 1, i = this.decimals;
            while (i--) diff /= 10;
            this.min = ((rounded - this.minValue) < diff) ? this.minValue : Math.max(rounded, this.minValue);
        }
        // when the rounded value is within the decimal precision of the boundary, use the boundary
        if (min > this.max) this.min = this.max;
        var s = this.displayFn ? this.displayFn(this.min) : this.min;
        if (s === '') return false;
        this.minBox.setValue(s, exact);
        this.valueSlider.setValue(0, this.min);
        if (this.displayFn) this.displayMin = this.displayFn(this.min);
        return true;
    },

    setMax: function (max, exact) {
        if (max > this.maxValue) this.maxValue = max;
        if (exact) {
            this.max = Math.min(max, this.maxValue);
        } else {
            var rounded = Ext.Number.toFixed(max, this.decimals);
            var diff = 1, i = this.decimals;
            while (i--) diff /= 10;
            this.max = ((this.maxValue - rounded) < diff) ? this.maxValue : Math.min(rounded, this.maxValue);
            // when the rounded value is within the decimal precision of the boundary, use the boundary
        }
        if (max < this.min) this.max = this.min;
        var s = this.displayFn ? this.displayFn(this.max) : this.max;
        if (s === '') return false;
        this.maxBox.setValue(s, exact);
        this.valueSlider.setValue(1, this.max);
        if (this.displayFn) this.displayMax = this.displayFn(this.max);
        return true;
    },

    getMin: function () {
        return this.min;
    },

    getMax: function () {
        return this.max
    },

    getValues: function () {
        return [this.min, this.max];
    },

    reset: function () {
        this.ignoreChange = true;
        this.valueSlider.setMaxValue(this.origMaxValue);
        this.valueSlider.setMinValue(this.origMinValue);
        this.sliderMin = this.origMinValue;
        this.sliderMax = this.origMaxValue;
        this.setValues(this.origMinValue, this.origMaxValue);
        this.ignoreChange = false;
    }
});
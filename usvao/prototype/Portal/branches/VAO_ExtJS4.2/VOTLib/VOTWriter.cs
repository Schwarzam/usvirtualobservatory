using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Collections;
using System.Collections.Generic;

using Collections;

namespace VOTLib
{
	public class VOTWriter : XmlTextWriter
	{

		protected readonly static OrderedDictionary<string, object> NO_ATTR = new OrderedDictionary<string, object>();
		private bool IncludeIds = false;
		private int fDataOutputLimit = 0;
		private string INTRO_COMMENT = 
			"This VO Table was generated by the VAO/STScI Data Discovery Portal.\n" + 
				"    While the data itself may have originated from another source, we make\n" +
				"    every attempt to accurately reproduce the original content.";

		public VOTWriter (TextWriter writer) : this(writer, 0, false)
		{
		}

		public VOTWriter (TextWriter writer, int iOutputDataLimit, bool iIncludeIds) : base(writer)
		{
			fDataOutputLimit = iOutputDataLimit;
			IncludeIds = iIncludeIds;
		}

		public bool WriteVoTable(IList a, out string invalidReason) {
			WriteStartDocument();
			WriteComment(INTRO_COMMENT);

			bool valid = WriteElement(a, out invalidReason);
			return valid;
		}
		
		public bool WriteVoTable(DataSet ds, out string invalidReason) {
			WriteStartDocument();
			WriteComment(INTRO_COMMENT);

			bool valid = true;
			invalidReason = "Table is valid";

			// See if this DataSet had attached VOT metadata.  If not, it means it was probably not created from an actual VO Table.
			IList votMetadata = (IList)ds.ExtendedProperties[Tags.VOT_METADATA];
			if (votMetadata != null) {
				// We have VO Table metadata, so we will use it.
				// If this were just the ArrayList writer, we would pass in votMetadata and be done with it.
				// However, this case is a hybrid approach.  The following things need to come from the DataSet instead:
				//   - Data
				//   - Field list.  The Field metadata should come from the array list, while the list of field names to include
				//     should come from the DataSet, since a user may have pruned the list of columns they want on export for exmaple.
				valid = WriteElement(votMetadata, ds, out invalidReason);
			} else {
				// We do not have VO Table metadata, so we will generate the output metadata from values in the DataSet.
				// TSD TODO
				WriteVoTableSimpleMetadata(ds);

			}

			return valid;
		}
		
		#region Write Utilities

		protected bool WriteElement(IList a, out string invalidReason) {
			bool valid = WriteElement(a, null, out invalidReason);
			return valid;
		}

		protected bool WriteElement(IList a, DataSet ds, out string invalidReason) {
			// The first item in the list is a dictionary containing the element metadata.
			// The second item is a dictionary containing the element attributes.
			bool valid = true;
			invalidReason = "Table is valid";
			try {
				if (a.Count >= 2) {
					IDictionary<string, object> metadata = (IDictionary<string, object>)a[0];
					IDictionary<string, object> attributes = (IDictionary<string, object>)a[1];
					string tag = (string)getVal(metadata, Tags.TAG_ATTR, null);
					if (tag != null) {
						int id = (int)getVal(metadata, Tags.ID_ATTR, 0);
						int parentId = (int)getVal(metadata, Tags.PARENT_ID_ATTR, 0);

						// Handle certain tags in special ways if we're using a hybrid approach with a DataSet.
						if ((ds != null) && tag.Equals(Tags.TABLE)) {
							DataTable dt = FindTable(id, ds);
							if (dt != null) {
								// Replace the current table element with one that has it's DataTable columns reconciled with its FIELDs.
								a = FixTableList(a, dt);
							}
						}

						// See if the element has any content.  If there are no more items, then there is no content.
						// If the next item is a list, it represents a subelement,
						// and all subsequent items will be subelements.  If the next item is not a list, then it should
						// be the last item and should be a dictionary representing texual content.
						if (a.Count == 2) {
							WriteTerminal(tag, id, parentId, attributes, null, false);
						} else if (a[2] is IList) {
							WriteNtBegin(tag, id, parentId, attributes);
							bool writeAllChildren = true;

							// We either have subelements or, if we're in a TR element, a list of data (TD elements compressed into one list).
							if (tag.Equals(Tags.TR)) {
								writeAllChildren = false;
								if (a.Count == 3) {
									WriteData(id, (IList)a[2]);
								} else {
									valid = false;
									invalidReason = "TR elements should contain only a single list of data.";
								}
							} else if ((ds != null) && tag.Equals(Tags.DATA)) {
								// We should write our data from the DataSet instead of data lists inside the TR elements.
								DataTable dt = FindTable(parentId, ds);  // The parent of this DATA element should be the TABLE element.
								if (dt != null) {
									writeAllChildren = false;
									WriteDataFromTableRows(dt);
								}
							} 

							if (writeAllChildren) {
								for (int i=2; i<a.Count && valid; i++) {
									valid = valid && WriteElement((IList)a[i], ds, out invalidReason);
								}
							}
							WriteNtEnd(tag, id, parentId);
						} else {
							if (a.Count == 3) {
								IDictionary<string, object> contentDict = (IDictionary<string, object>)a[2];
								bool literal = false;
								string content = (string)getVal(contentDict, Tags.CONTENT_ATTR, null);
								if (content == null) {
									// It must be a literal string instead, but just in case, we'll default to "".
									content = (string)getVal(contentDict, Tags.LITERAL_CONTENT_ATTR, "");
									literal = true;
								}
								WriteTerminal(tag, id, parentId, attributes, content, literal);
							} else {
								valid = false;
								invalidReason = "Element (tag = " + tag + ") had more items after simple content.";
							}
						}

					} else {
						valid = false;
						invalidReason = "Element had null tag.";
					}


				} else {
					valid = false;
					invalidReason = "Element had less than 2 items.";
				}
			} catch (InvalidCastException e) {
				valid = false;
				Console.WriteLine(e);
				invalidReason = e.ToString();
			}

			return valid;
		}
		
		public void WriteIds(int id, int parentId) {			
			if (IncludeIds) {
				WriteAttributeString(Tags.ID_ATTR, id.ToString());
				WriteAttributeString(Tags.PARENT_ID_ATTR, parentId.ToString());
			}
		}

		public void WriteAttributes(IDictionary<string, object> attributes) {
			foreach (KeyValuePair<string, object> e in attributes) {
				WriteAttributeString(e.Key.ToString(), e.Value.ToString());
			}
		}

		public void WriteNtBegin(string tag, int id, int parentId, IDictionary<string, object> attributes) {
			WriteStartElement(tag);
			WriteIds (id, parentId);
			WriteAttributes(attributes);
		}
		
		public void WriteNtEnd(string tag, int id, int parentId) {
			if (IncludeIds) {
				string s = String.Format("Closing tag {0}, id=\"{1}\" parentId=\"{2}\"", tag, id, parentId);
				WriteComment(s);
			}
			WriteEndElement();
		}
		
		public void WriteTerminal(string tag, int id, int parentId, IDictionary<string, object> attributes, string content, bool isLiteral) {
			WriteStartElement(tag);
			WriteIds (id, parentId);
			WriteAttributes(attributes);
			if (content != null) {
				if (isLiteral) {
					WriteRaw(content);
				} else {
					WriteString(content);
				}
			}
			WriteEndElement();
		}
		
		public void WriteData (int trId, IList dataValues)
		{
			int limit = dataValues.Count;
			bool trim = (fDataOutputLimit > 0) && (fDataOutputLimit < dataValues.Count);
			if (trim) {
				limit = fDataOutputLimit;
			}
			for (int i=0; i<limit; i++) {
				object o = dataValues[i];
				WriteElementString(Tags.TD, (string)o);
			}
			if (trim) {
				WriteComment ("...");
			}
		}

		protected void WriteVoTableSimpleMetadata(DataSet ds) {
			OrderedDictionary<string, object> attr = new OrderedDictionary<string, object>();

			// Write boilerplate VOTABLE element with description:
			// <VOTABLE version="1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			// xmlns="http://www.ivoa.net/xml/VOTable/v1.2"
			//	xsi:schemaLocation="http://www.ivoa.net/xml/VOTable/v1.2 http://www.ivoa.net/xml/VOTable/v1.2">
			attr.Add("version", "1.2");
			attr.Add("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
			attr.Add("xmlns", "http://www.ivoa.net/xml/VOTable/v1.2");
			attr.Add("xsi:schemaLocation", "http://www.ivoa.net/xml/VOTable/v1.2 http://www.ivoa.net/xml/VOTable/v1.2");
			WriteNtBegin(Tags.VOTABLE, -1, -1, attr);

			WriteTerminal(Tags.DESCRIPTION, -1, -1, NO_ATTR, ds.DataSetName, false);

			// Even if the DataSet contains more than one table, we will only write out the first one.
			DataTable table = ds.Tables[0];
			WriteNtBegin(Tags.RESOURCE, -1, -1, NO_ATTR);
			WriteNtBegin(Tags.TABLE, -1, -1, NO_ATTR);

			// Write the FIELDs
			WriteFieldsFromTableColumns(table);

			// Write the DATA
			WriteNtBegin(Tags.DATA, -1, -1, NO_ATTR);
			WriteDataFromTableRows(table);
			WriteNtEnd(Tags.DATA, -1, -1);

			// Close the open elements.
			WriteNtEnd(Tags.TABLE, -1, -1);
			WriteNtEnd(Tags.RESOURCE, -1, -1);
			WriteNtEnd(Tags.VOTABLE, -1, -1);
		}

		protected void WriteFieldsFromTableColumns(DataTable dt) {
			OrderedDictionary<string, object> attr = new OrderedDictionary<string, object>();

			// Add one FIELD element for each column.
			foreach (DataColumn col in dt.Columns) {
				attr.Clear();
				
				// Add name and datatype attributes.
				attr.Add("name", col.ColumnName);
				string datatype;
				if (VOTType.VotTypeMapping.TryGetValue(col.DataType, out datatype)) {
					attr.Add("datatype", datatype);
				}

				// Add any remaining VoTable Properties for this column that are stored as ExtendedProperties vith prefix "vot."
				// If we got here, it's unlikely any of these exist, since they usually come from a VO Table original, which would
				// have had the ArrayList metadata instead.
				//
				string description = null;
				object ignoreValue = null;
				if (col.ExtendedProperties != null) {
					PropertyCollection properties = col.ExtendedProperties;	
					foreach (string key in properties.Keys) {
						if (key.StartsWith("vot.")) {
							string votparam = (key.Substring(4));
							string votvalue = properties[key] as string;
							
							if (votparam.ToUpper().Equals("DESCRIPTION")) {
								description = votvalue;
							} else {
								attr.Add(votparam, votvalue);
							}
						} else if (key.Equals("cc.ignoreValue")) {
							ignoreValue = properties[key];
						}
					}
				}
				
				// Open the FIELD element.
				WriteNtBegin(Tags.FIELD, -1, -1, attr);

				// Write the description, if present.
				if (description != null) {
					WriteTerminal(Tags.DESCRIPTION, -1, -1, NO_ATTR, description, false);
				}

				// Write the VALUES element if there is an ignore value to specify.
				if (ignoreValue != null) {
					OrderedDictionary<string, object> valuesAttr = new OrderedDictionary<string, object>(1);
					valuesAttr["null"] = ignoreValue.ToString();
					WriteNtBegin(Tags.VALUES, -1, -1, valuesAttr);
					WriteNtEnd(Tags.VALUES, -1, -1);
				}

				// Close the FIELD element.
				WriteNtEnd(Tags.FIELD, -1, -1);
			}
		}

		protected void WriteDataFromTableRows(DataTable dt) {
			WriteNtBegin(Tags.TABLEDATA, -1, -1, NO_ATTR);

			foreach (DataRow row in dt.Rows) {
				WriteNtBegin(Tags.TR, -1, -1, NO_ATTR);
				foreach (DataColumn col in dt.Columns) {
					WriteValue(row, col);
				}
				WriteNtEnd(Tags.TR, -1, -1);
			}

			WriteNtEnd(Tags.TABLEDATA, -1, -1);
		}

		protected void WriteValue(DataRow row, DataColumn col) {
			object val = row[col];
			object nullVal = col.ExtendedProperties["cc.ignoreValue"];
			// Check to see if the stored value equals the value that represents null for this column.
			// Although writing out the specified value is legal to represent null, writing out an empty string seems
			// clearer and less susceptible to misinterpretation.
			if ((nullVal != null) && nullVal.Equals(val)) {
				val = "";
			}
			
			// If the stored value is null, we will always write that out as the empty string, hoping that numeric
			// types have included an appropriate VALUES null attribute.
			Type valueType = val.GetType();
			string valueTypeString = valueType.Name;
			if (valueTypeString == "DBNull") {
				val = "";
			}
			string valString = val.ToString();

			// The VO Table expects "Inf" or "-Inf" instead of "Infinity" or "-Infinity".
			if (((val is Double) && Double.IsInfinity((double)val)) ||
			    ((val is Single) && Single.IsInfinity((float)val))) {
				valString = valString.Replace("inity", "");
			}
			WriteTerminal(Tags.TD, -1, -1, NO_ATTR, valString, false);
		}

		#endregion

		#region Utility Methods
		private object getVal(IDictionary<string, object> dict, string key, object defaultVal) {
			object o = null;
			if (!dict.TryGetValue(key, out o)) {
				o = defaultVal;
			}
			return o;
		}

		private int getEpIntVal(PropertyCollection ep, string key, int defaultVal) {
			int result = defaultVal;
			object o = ep[key];
			if (o != null) {
				// We know we stored it as an int.
				result = (int)o;
			}
			return result;
		}

		/*
		 * Given the id (derived during original VO Table parsing), this method returns which DataTable in the given DataSet
		 * has a votMetadata object that is exactly the same object as tableElement.
		 */
		private DataTable FindTable(int id, DataSet ds) {
			DataTable result = null;
			foreach (DataTable dt in ds.Tables) {
				int tableId = getEpIntVal(dt.ExtendedProperties, Tags.ID_ATTR, -1);
				if (tableId != -1) {
					if (id == tableId) {
						result = dt;
						break;
					}
				}
			}
			return result;
		}

		/**
		 * The intent of this is to reconcile the incoming List representation of the table with the column definitions
		 * provided by the DataTable representation.  The main reason they will differ is during an "export" action, where
		 * the columns have been removed or reordered.
		 * 
		 * The goal is that the output of FIELDs correspond as closely as possible to the original VO Table.  Since VO Tables
		 * allow interleaving of FIELDs with some other elements (why?!), that preservation is a little challenging.  Once
		 * any changes in columns have happened, it is not important to preserve the original look, so we will write the rest
		 * of the fields together.
		 */
		private IList FixTableList(IList table, DataTable dt) {
			int numCols = dt.Columns.Count;
			int tblLen = table.Count;
			ArrayList fixedTable = new ArrayList();
			int tblPtr = 0;
			int colPtr;
			bool done = false;
			bool match = true;
			bool abort = false;
			// Loop through all columns in the DataTable.  It is those columns that control what we output.
			for (colPtr=0; colPtr<numCols && !done; colPtr++) {
				DataColumn c = dt.Columns[colPtr];
				int colId = getEpIntVal(c.ExtendedProperties, Tags.ID_ATTR, -1);
				if (colId != -1) {
					// We found the ID of the column, so we can see if there is a matching FIELD element in metadata representation.
					for (match=false; tblPtr<tblLen && !match && !abort; tblPtr++) {
						if (table[tblPtr] is IList) {
							IList elt = (IList)table[tblPtr];
							IDictionary<string, object> metadata = (IDictionary<string, object>)elt[0];
							string tag = (string)getVal(metadata, Tags.TAG_ATTR, null);
							if (Tags.FIELD.Equals(tag)) {
								int fieldId = (int)getVal(metadata, Tags.ID_ATTR, null);
								if (colId == fieldId) {
									// We are in sync
									match = true;
									fixedTable.Add(table[tblPtr]);
								} else {
									// This field doesn't match the column list, so we need to just use the column list.
									abort = true;
								}
							} else {
								fixedTable.Add(table[tblPtr]);
							}
						} else {
							fixedTable.Add(table[tblPtr]);
						}
					}
					if (abort) {
						done = true;
					}
				} else {
					// We don't have IDs.  We'll have to completely ignore this and write it assuming that we never parsed an original VO Table.
					done = true;
				}
			}

			if (fixedTable != null) {
				// Add the rest of the columns if any are left.
				if (abort) colPtr--;  // abort means we ended early, but the loop counter incremented one more time. 
				for (; colPtr<numCols; colPtr++) {
					bool added = false;
					DataColumn c = dt.Columns[colPtr];
					int colId = getEpIntVal(c.ExtendedProperties, Tags.ID_ATTR, -1);
					if (colId != -1) {
						IList fieldElt = FindField(table, colId); 
						if (fieldElt != null) {
							fixedTable.Add (fieldElt);
							added = true;
						}
					}
					if (!added) {
						// Add a fake element based on the column's extended properties.
						AddFieldFromColumn(fixedTable, c);
					}
				}

				// Copy the rest of the table, but without any more FIELDs.
				for (; tblPtr<tblLen; tblPtr++) {
					if (table[tblPtr] is IList) {
						IList elt = (IList)table[tblPtr];
						IDictionary<string, object> metadata = (IDictionary<string, object>)elt[0];
						string tag = (string)getVal(metadata, Tags.TAG_ATTR, null);
						if (!Tags.FIELD.Equals(tag)) {
							fixedTable.Add(table[tblPtr]);
						}
					} else {
						fixedTable.Add(table[tblPtr]);
					}
				}
			}

			return fixedTable;
		}

		private IList FindField(IList table, int id) {
			IList result = null;
			for (int i=0; i<table.Count && (result==null); i++) {
				if (table[i] is IList) {
					IList elt = (IList)table[i];
					IDictionary<string, object> metadata = (IDictionary<string, object>)elt[0];
					string tag = (string)getVal(metadata, Tags.TAG_ATTR, null);
					if (Tags.FIELD.Equals(tag)) {
						int fieldId = (int)getVal(metadata, Tags.ID_ATTR, null);
						if (id == fieldId) {
							result = elt;
						}
					}
				}
			}
			return result;
		}

		private IList AddFieldFromColumn(ArrayList parentList, DataColumn col) {
			PropertyCollection ep = col.ExtendedProperties;
			OrderedDictionary<string, object> attributes = new OrderedDictionary<string, object>();
			string description = null;

			foreach (string key in ep.Keys) {
				if (key.Equals("vot.description")) {
					description = (string)ep[key];
				} else if (key.StartsWith("vot.")) {
					string attrName = key.Substring(4);
					attributes.Add(attrName, ep[key]);
				}
			}

			ArrayList newField = ArrayListReceiver.CreateAndAddElement(parentList, Tags.FIELD, -1, -1, attributes);
			if (description != null) {
				ArrayListReceiver.CreateAndAddTerminalElement(newField, Tags.DESCRIPTION, -1, -1, new OrderedDictionary<string, object>(), description, false);
			}
			return newField;
		}

		#endregion
	}
}


/*
 * File: app/view/MinMaxSliderContainer.js
 * Date: Thu Jan 26 2012 11:26:47 GMT-0500 (Eastern Standard Time)
 *
 * This file was generated by Ext Designer version 1.2.2.
 * http://www.sencha.com/products/designer/
 *
 * This file will be generated the first time you export.
 *
 * You should implement event handling and custom methods in this
 * class.
 */

Ext.require('Mvp.util.Coords');
Ext.require('Mvp.util.Util');

Ext.define('Mvpc.view.MinMaxSliderContainer', {
    extend: 'Mvpc.view.ui.MinMaxSliderContainer',
    alias: 'widget.minmaxslidercontainer',

    initComponent: function () {
        var me = this;
        me.callParent(arguments);
    },

    constructor: function (config) {
        this.callParent(arguments);

        this.facetName = config.facetName;
        this.minValue = config.minValue;
        this.maxValue = config.maxValue;
        this.displayFn = config.displayFn;
        this.readFn = config.readFn;
        this.store = config.store;
        this.zoomable = false;
        this.ignoreValue = config.ignoreValue;

        this.histogramContainer = this.getComponent('histogramContainer');
        this.sliderContainer = this.getComponent('sliderContainer');

        if (AppConfig.extVersion != '4.0.2') {
            this.zoomCheckbox = Ext.create('Ext.form.field.Checkbox', {
                fieldLabel: 'Zoom to range',
                checked: this.zoomable
            });
            this.zoomCheckbox.on('change', this.zoomChange, this);
            //this.add(this.zoomCheckbox);
        }

        var diff = this.maxValue - this.minValue,
            increment = diff / 1000,
            decimals = Math.max(Math.floor(-Math.log(increment) / Math.LN10), 0);
        // calculate a more appropriate decimal precision relative to magnitude of the range

        this.valueSlider = Ext.create('Ext.slider.Multi', {
            itemId: 'valueSlider',
            minValue: this.minValue,
            maxValue: this.maxValue,
            values: [this.minValue, this.maxValue],
            width: 231,
            margin: '0 0 0 5',
            decimalPrecision: decimals,
            keyIncrement: increment * 10
        });
        this.sliderContainer.add(this.valueSlider);

        this.minmaxContainer = this.getComponent('minmaxContainer');
        this.minBox = this.minmaxContainer.getComponent('minBox');
        this.maxBox = this.minmaxContainer.getComponent('maxBox');
        this.setMin(this.minValue);     // avoid setValues in constructor so we don't fire events
        this.setMax(this.maxValue);

        this.minBox.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.minmaxChanged();
            }
        }, this);
        this.maxBox.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                this.minmaxChanged();
            }
        }, this);
        this.minmaxContainer.getComponent('resetButton').on('click', this.reset, this);
        this.valueSlider.addListener('changecomplete', this.sliderChanged, this);
        this.on('render', this.configHistogram, this);
    },

    configHistogram: function () {
        if (AppConfig.extVersion != '4.0.2') {
            var min = (this.zoomable) ? this.min : this.minValue,
                max = (this.zoomable) ? this.max : this.maxValue;
            if (!this.hist || this.zoomable) {
                this.hist = Mvp.util.Util.decimalHistogram(this.store, this.facetName, min, max, 100, this.ignoreValue);
            }
            if (this.histogram) this.histogramContainer.removeAll();
            this.histogram = {
                xtype: 'chart',
                theme: 'Blue',
                height: 70,
                width: 260,
                store: this.hist.store,
                axes: [{
                    minimum: 0,
                    maximum: this.hist.max,
                    position: 'left',
                    hidden: true,      // need min/max but don't want to show values, just ratios
                    type: 'Numeric',
                    fields: ['ratio']
                }, {
                    minimum: min,
                    maximum: max,
                    majorTickSteps: 1,
                    minorTickSteps: 0,
                    position: 'bottom',
                    fields: ['bucket'],
                    type: 'Numeric'
                }],
                series: [{
                    type: 'column',
                    xField: 'bucket',
                    yField: 'ratio',
                    axis: 'left',
                    gutter: 1.0,   // default spacing is so large the lines don't display
                    xPadding: 10   // makes room for the leftmost tick label
                }]
            };
            this.histogramContainer.add(this.histogram);
        }
    },

    zoomChange: function (obj, val) {
        this.zoomable = val;
        this.configHistogram();
    },

    minmaxChanged: function () {
        var min = this.minBox.getValue(),
            max = this.maxBox.getValue(),
            minDeg = (this.readFn) ? this.readFn(min) : Number(min),
            maxDeg = (this.readFn) ? this.readFn(max) : Number(max);
        if ((minDeg != undefined) && (maxDeg != undefined)) this.setValues(minDeg, maxDeg);
    },

    sliderChanged: function () {
        var vals = this.valueSlider.getValues();
        this.setValues(vals[0], vals[1]);
    },

    setValues: function (min, max) {
        this.setMin(min);
        this.setMax(max);
        if (this.zoomable) this.configHistogram();
        this.fireEvent('rangeChanged', this.facetName, this.getValues());
        if ((min == this.minValue) && (max == this.maxValue)) {
            this.fireEvent('filterRemoved', this.facetName);
        }
    },

    setMin: function (min) {
        this.min = Math.max(min, this.minValue);
        if (min > this.max) this.min = this.max;
        this.minBox.setValue(this.displayFn ? this.displayFn(this.min) : this.min);
        this.valueSlider.setValue(0, this.min);
    },

    setMax: function (max, fireEvent) {
        this.max = Math.min(max, this.maxValue);
        if (max < this.min) this.max = this.min;
        this.maxBox.setValue(this.displayFn ? this.displayFn(this.max) : this.max);
        this.valueSlider.setValue(1, this.max);
    },

    getMin: function () {
        return this.min;
    },

    getMax: function () {
        return this.max
    },

    getValues: function () {
        return [this.min, this.max];
    },

    reset: function () {
        this.setValues(this.minValue, this.maxValue);
    }
});
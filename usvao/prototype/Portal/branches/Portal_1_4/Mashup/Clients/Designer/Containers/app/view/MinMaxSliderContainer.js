/*
* File: app/view/MinMaxSliderContainer.js
* Date: Thu Jan 26 2012 11:26:47 GMT-0500 (Eastern Standard Time)
*
* This file was generated by Ext Designer version 1.2.2.
* http://www.sencha.com/products/designer/
*
* This file will be generated the first time you export.
*
* You should implement event handling and custom methods in this
* class.
*/

Ext.define('Mvpc.view.MinMaxSliderContainer', {
    extend: 'Mvpc.view.ui.MinMaxSliderContainer',
    alias: 'widget.minmaxsliderContainer',
    requires: ['Mvp.util.Coords', 'Mvp.util.Util', 'Ext.slider.Multi', 'Ext.chart.Chart', 'Ext.data.JsonStore', 'Ext.data.reader.Json', 'Ext.chart.series.Column', 'Ext.chart.axis.Numeric', 'Ext.chart.theme.Base', 'Mvp.util.Constants'],

    initComponent: function () {
        var me = this;
        me.callParent(arguments);
    },

    constructor: function (config) {
        Ext.apply(this, config);
        this.callParent(arguments);

        // The chart widget name seems to have to be defined in the Ext.chart.theme namespace, and I couldn't get it to
        // execute correctly as a standalone call
        if (!Ext.chart.theme.MvpTheme) Ext.chart.theme.MvpTheme = Ext.extend(Ext.chart.theme.Base, {
            constructor: function (config) {
                Ext.chart.theme.Base.prototype.constructor.call(this, Ext.apply({
                    colors: ['#133987', '#c0c0c0']
                }, config));
            }
        });

        this.setTitle(this.title);

        this.app = window.app;
        var em = this.app.getEventManager();
        em.addListener('APP.context.records.filtered', this.configHistogram, this);
        this.store = Mvp.util.Util.potentialHistogramToStore(this.hist.hist);
        this.zoomStore = undefined;

        this.histogramContainer = this.getComponent('histogramContainer');
        this.sliderContainer = this.getComponent('sliderContainer');
        this.buttonContainer = this.getComponent('buttonContainer');
        this.zoomButton = this.buttonContainer.getComponent('zoomButton');
        this.zoomButton.addListener('click', this.zoom, this, { zoom: true });
        this.decimals = (this.maxValue - this.minValue) ? this.discrete ? 0 : Math.max(Math.floor(-Math.log(this.increment) / Math.LN10), 2) : 4;
        // calculate a more appropriate decimal precision relative to magnitude of the range

        this.sliderMin = this.minValue;
        this.sliderMax = this.maxValue;
        this.valueSlider = Ext.create('Ext.slider.Multi', {
            itemId: 'valueSlider',
            minValue: this.sliderMin,
            maxValue: this.sliderMax,
            values: [this.minValue, this.maxValue],
            width: 231,
            margin: '0 0 0 5',
            decimalPrecision: this.discrete ? 0 : false,
            useTips: {
                xtype: 'slidertip',
                position: 'right',
                padding: 0,
                //align: 'b-t?',
                //offsets: '[0, -3]',
                getText: function (thumb) {
                    var displayFn = thumb.slider.scope.displayFn;
                    return displayFn ? displayFn(thumb.value) : Ext.Number.toFixed(thumb.value, thumb.slider.scope.decimals);
                }
            },
            scope: this
        });
        this.sliderContainer.add(this.valueSlider);

        this.guideline = Ext.create('Ext.container.Container', {
            height: 50,
            width: 1,
            title: false,
            hidden: true,
            shadow: false,
            closable: false,
            floating: true,
            resizable: false,
            style: {
                'background-color': 'orange',
                'border': 'transparent'
            }
        });

        this.minmaxContainer = this.getComponent('minmaxContainer');
        this.minBox = this.minmaxContainer.getComponent('minBox');
        this.maxBox = this.minmaxContainer.getComponent('maxBox');
        this.setMin(this.minValue);     // avoid setValues in constructor so we don't fire events
        this.setMax(this.maxValue);

        this.minBox.on({
            'specialkey': function (f, e) { if (e.getKey() == e.ENTER) this.minmaxChanged(); },
            'blur': this.minmaxChanged,
            scope: this
        });
        this.maxBox.on({
            'specialkey': function (f, e) { if (e.getKey() == e.ENTER) this.minmaxChanged(); },
            'blur': this.minmaxChanged,
            scope: this
        });
        this.resetButton = this.buttonContainer.getComponent('resetButton').disable();
        this.resetButton.on('click', this.reset, this);
        this.valueSlider.on({
            changecomplete: this.sliderChanged,
            dragend: this.hideLines,    // changecomplete doesn't fire if there isn't a change
            drag: this.moveLines,
            scope: this
        });

        if (this.ignoreValue !== undefined) {
            var cb = {
                xtype: 'label',
                text: 'The value (' + this.ignoreValue + ') is ignored by this filter',
                margin: '0 0 0 7'
            };
            this.add(cb);
        };

        this.on({
            expand: this.configHistogram,
            scope: this
        });
    },

    zoom: function (obj, e, config) {
        this.valueSlider.setMaxValue(this.max);
        this.valueSlider.setMinValue(this.min);
        this.sliderMax = this.max;
        this.sliderMin = this.min;
        this.configHistogram(config);
    },

    configHistogram: function (config) {
        if (!this.histogramContainer.isVisible(true)) return;
        Ext.log(this.facetName + ' configured');
        var zoom = (config && config.zoom);

        //if (this.histogram) this.histogramContainer.removeAll();
        var i = this.passThrough.potentialStores ? this.passThrough.potentialStores.length : 0;
        var found = false;
        while (i--) {
            var s = this.passThrough.potentialStores[i];
            if (s.column == this.facetName) {
                this.zoomHist = Mvp.util.Util.potentialHistogram(s.store.items, this.facetName, zoom ? this.min : this.sliderMin, zoom ? this.max : this.sliderMax, Mvp.util.Constants.NUMERIC_HISTOGRAM_BUCKETS, this.ignoreValue, this.min, this.max);
                found = true;
                break;
            }
        }
        if (!found) this.zoomHist = Mvp.util.Util.potentialHistogram(this.originalStore.backingStore.data.items, this.facetName, zoom ? this.min : this.sliderMin, zoom ? this.max : this.sliderMax, Mvp.util.Constants.NUMERIC_HISTOGRAM_BUCKETS, this.ignoreValue, this.min, this.max);
        this.zoomStore = Mvp.util.Util.potentialHistogramToStore(this.zoomHist.histArray);

        if (this.histogram) this.histogramContainer.removeAll();
        this.histogram = Ext.create('Ext.chart.Chart', {
            theme: 'MvpTheme',
            height: 70,
            width: 260,
            padding: 0,
            store: this.zoomStore,
            shadow: false,
            axes: [{
                minimum: 0,
                maximum: this.zoomHist.max || 1,    // the || 1 assures that there is a y height on a zoomed histogram
                position: 'left',
                hidden: true,      // need min/max but don't want to show values, just ratios
                type: 'Numeric',
                fields: ['count', 'excluded']
            }, {
                minimum: this.sliderMin,
                maximum: this.sliderMax,
                majorTickSteps: 0,
                minorTickSteps: 0,
                position: 'bottom',
                fields: ['key'],
                type: 'Numeric',
                label: { xtype: 'label', text: '' }
            }],
            series: [{
                type: 'column',
                xField: 'key',
                yField: ['count', 'excluded'],
                axis: 'left',
                stacked: true,
                gutter: 0.0,   // default spacing is so large the lines don't display
                xPadding: 10   // makes room for the leftmost tick label
            }]
        });
        this.histogramContainer.add(this.histogram);

        if ((this.sliderMin == this.min) && (this.sliderMax == this.max)) {
            this.zoomButton.disable();
        } else {
            this.zoomButton.enable();
        }
    },

    minmaxChanged: function () {
        var min = this.minBox.getValue(),
            max = this.maxBox.getValue(),
            minDeg = (this.readFn) ? this.readFn(min) : Number(min),
            maxDeg = (this.readFn) ? this.readFn(max) : Number(max);
        if (this.readFn && this.displayFn) {
            if ((minDeg == this.readFn(this.displayMin)) && (maxDeg == this.readFn(this.displayMax))) return false;
        }
        if ((minDeg !== undefined) && (maxDeg !== undefined) && (minDeg !== '') && (maxDeg !== '')) this.setValues(minDeg, maxDeg);
    },

    sliderChanged: function () {
        this.ignoreChange = true;
        var vals = this.valueSlider.getValues();
        if (!this.setValues(vals[0], vals[1])) this.hideLines();
        this.ignoreChange = false;
    },

    setValues: function (min, max) {
        if ((min == this.min) && (max == this.max)) return false;
        var prevMin = this.min;
        var prevMax = this.max;
        if (!this.setMin(min) || !this.setMax(max)) {
            this.setMin(prevMin);
            this.setMax(prevMax);
            return;
        }
        this.resetButton.enable();
        this.fireEvent('rangeChanged', this.facetName, this.getValues());
        if ((min == this.minValue) && (max == this.maxValue)) {
            this.resetButton.disable();
            this.fireEvent('filterRemoved', this.facetName);
        }
    },

    setMin: function (min) {
        var rounded = Ext.Number.toFixed(min, this.decimals);
        var diff = 1, i = this.decimals;
        while (i--) diff /= 10;
        this.min = ((rounded - this.minValue) < diff) ? this.minValue : Math.max(rounded, this.minValue);
        // when the rounded value is within the decimal precision of the boundary, use the boundary
        if (min > this.max) this.min = this.max;
        var s = this.displayFn ? this.displayFn(this.min) : this.min;
        if (s === '') return false;
        this.minBox.setValue(s);
        this.valueSlider.setValue(0, this.min);
        if (this.displayFn) this.displayMin = this.displayFn(this.min);
        return true;
    },

    setMax: function (max, fireEvent) {
        var rounded = Ext.Number.toFixed(max, this.decimals);
        var diff = 1, i = this.decimals;
        while (i--) diff /= 10;
        this.max = ((this.maxValue - rounded) < diff) ? this.maxValue : Math.min(rounded, this.maxValue);
        // when the rounded value is within the decimal precision of the boundary, use the boundary
        if (max < this.min) this.max = this.min;
        var s = this.displayFn ? this.displayFn(this.max) : this.max;
        if (s === '') return false;
        this.maxBox.setValue(s);
        this.valueSlider.setValue(1, this.max);
        if (this.displayFn) this.displayMax = this.displayFn(this.max);
        return true;
    },

    getMin: function () {
        return this.min;
    },

    getMax: function () {
        return this.max
    },

    getValues: function () {
        return [this.min, this.max];
    },

    reset: function () {
        this.ignoreChange = true;
        this.valueSlider.setMaxValue(this.maxValue);
        this.valueSlider.setMinValue(this.minValue);
        this.sliderMin = this.minValue;
        this.sliderMax = this.maxValue;
        this.setValues(this.minValue, this.maxValue);
        this.ignoreChange = false;
    },

    moveLines: function () {
        if (this.ignoreChange) return;
        this.showLines();
        var which = this.valueSlider.thumbs[0].dragging ? 0 : 1;    // 0 = min thumb, 1 = max thumb
        this.guideline.el = Ext.get(this.guideline.id);
        this.guideline.alignTo(this.valueSlider.thumbs[which], 'b-t?', [(which ? 1 : 0), -18]);   // slightly offset the line position
    },

    hideLines: function () {
        this.guideline.hide();
    },

    showLines: function () {
        this.guideline.show();
    }
});
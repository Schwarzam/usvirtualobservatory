/*
 * File: app/view/ExportToWindow.js
 * Date: Fri Aug 19 2011 09:22:34 GMT-0400 (EDT)
 *
 * This file was generated by Ext Designer version 1.2.0.
 * http://www.sencha.com/products/designer/
 *
 * This file will be generated the first time you export.
 *
 * You should implement event handling and custom methods in this
 * class.
 */

Ext.define('Mvpd.view.ExportToWindow', {
    extend: 'Mvpd.view.ui.ExportToWindow',

    statics: {

        optionMap: {
            csv: {item: {inputValue: 'csv', boxLabel: 'Comma Separated Values (.csv)', name: 'filetype', xtype: 'radiofield'},
                extension: 'csv'},
            votable: {item: {inputValue: 'votable', boxLabel: 'VO Table (.xml)', name: 'filetype', xtype: 'radiofield'},
                extension: 'xml'},
            xls: {item: {inputValue: 'xls', boxLabel: 'Excel Spreadsheet (.xls)', name: 'filetype', xtype: 'radiofield'},
                extension: 'xls'},
            html: {item: {inputValue: 'html', boxLabel: 'HTML file (.html)', name: 'filetype', xtype: 'radiofield'},
                extension: 'html'},
            xml: {item: {inputValue: 'xml', boxLabel: 'Generic XML (.xml)', name: 'filetype', xtype: 'radiofield'},
                extension: 'xml'}
        }
    },

    initComponent: function() {
        var me = this;
        //var store = Ext.create('Mvpd.store.WhichColumnsStore');

        //store.load();
        
       
        me.callParent(arguments);
        
        // Get direct references to important components.
        me.exportButton = me.query('#exportButton')[0];
        me.cancelButton = me.query('#cancelButton')[0];
        me.filenameField = me.query('#filenameField')[0];
        me.filetypeRadios = me.query('#filetypeRadios')[0];
        me.actionRadios = me.query('#actionRadios')[0];
        me.columnsRadios = me.query('#columnsRadios')[0];
        
        // Add filetype options.
        var opt = Mvpd.view.ExportToWindow.optionMap;
        var items = [opt['csv'].item,
                    opt['votable'].item,
                    opt['xls'].item,
                    opt['html'].item,
                    opt['xml'].item
                    ];
        me.filetypeRadios.add(items);
        
        // Set up user-supplied handler.
        if (me.exportHandler) {
            me.exportButton.on('click', me.exportHandler, me);
        }
        
        // Set up internal cancel handler.
        me.cancelButton.on('click', me.closeWindow, this);
        
        me.filetypeRadios.on('change', me.filetypeChanged, this);
    },
 
    closeWindow: function() {
        this.hide();
        this.destroy();
    },
    
    setFilename: function(value) {
        this.filenameField.setValue(value);
    },
    
    getFilename: function() {
        var filename = this.filenameField.getValue();
        
        return filename;
    },
    
    setFiletype: function(filetype) {
        this.filetypeRadios.setValue({filetype: filetype});
    },
    
    getFiletype: function() {
        var filetype = this.filetypeRadios.getValue().filetype;
        
        return filetype;
    },
    
    getAction: function() {
        var action = this.actionRadios.getValue().destination;
        return action;
    },
    
    getAttachment: function() {
        var action = this.getAction();
        var attachment = (action === 'file');
        
        return attachment;
    },
    
    getFiltercolumns: function() {
        var exportColumns = this.columnsRadios.getValue().exportColumns;
        var filtercolumns = false;
        if (exportColumns === 'displayed') {
            filtercolumns = true;
        }
        return filtercolumns;
    },
    
    setFileExtension: function(extension) {
        var currentVal = this.getFilename();
        var newVal = currentVal.replace(/\.[^\.]*$/, '.' + extension);
        this.setFilename(newVal);
    },
    
    filetypeChanged: function(radioGroup, newValue, oldValue) {
        // Note:  The newValue argument is not reliable here as it seems to be able to contain both the old and new values.
        // What seems to happen is that when a new radio button is clicked, we get this call twice.  The first time newValue
        // is an array containing both the old and new buttons.  The second time newValue is just a string containing the new
        // value.  The workaround is to ignore this call when newValue is an array.
        var newFiletype = this.filetypeRadios.getValue().filetype;
        if (!Ext.isArray(newFiletype)) {
            var extension = Mvpd.view.ExportToWindow.optionMap[newFiletype].extension;
            Ext.log('Setting export file extension to ' + extension);
            this.setFileExtension(extension);
        }
    }
    
    
});
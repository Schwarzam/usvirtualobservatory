<HTML>
<HEAD> <TITLE> TABLE READING LIBRARY </TITLE> </HEAD>
<BODY TEXT="#000000" LINK="#222222" VLINK="#551A8B" ALINK="#0000ff" bgcolor="#faaf99">

<H1><center> TABLE READING LIBRARY </center></H1>
<H3><center> Delivered by <i> John Good </i> and <i>Angela Zhang</i> </center></H3>
<p> &nbsp </p>
<p> &nbsp </p>

<H2> INTRODUCTION </H2>
<p> &nbsp </p>
<p><font size=4>

This library is designed to provide a powerful yet simple interface for
accessing table files, which can either be written in ISIS
format or FITS format. The ISIS format consists of IPAC ASCII table and
IPAC FIXED LENGTH ASCII table, while FITS format consists of FITS ASCII
table and FITS BINARY table. The library calls CFITSIO FITS library and
ISIS(IPAC) library routines. However, it is not required that users have a
general knowledge about the structure and usage of FITS files.

<p><font size=4>
The library provides the capbility of reading variaty table without
requiring any knowlage about an input talbe format ahead.
Table type is determined on the running time by the library.
The information about such a file is stored in a structure. File information 
includes input file name, table type, number of keywords, 
number of rows, and number of columns. The information is released on the
request basis.

<p><font size=4>
Futhermore, the library also provides a structure to store a column 
information, such as:
column name, data type, null value, scaling factor, offset of the data,
column width, and sugested display format.

<p><font size=4>
User is able to acquire the information about a keyword in a file too. There 
are many subroutines. Based on these routines library is able to provide 
over all functionalities.
However, user only need to call the following discussed routines. Access to low level subroutines are not recommented.

<p><font size=4>
The purpose of this document is to help users get familiar with application
program interface.  This document is divided into two parts. The first half 
introduces routines which start with isis. Those routines are used for ISIS 
data formatd.
The second half introduce wrapping routines started with tbl which are
used for both FITS data formats and ISIS fromat.  The library is designed
to provide flexibility, so that isis routines can be used seperatly. But
using wrapping routines are highly encouraged.

<p><font size=4>
Mantain and updata table library is long-term task. If any one has any
suggestion, comment, and criticize, please forword your message to:
<center>
	jcg@ipac.caltech.edu or azhang@ipac.caltech.edu.
</center>
If any one finds any problem or bug with the library, please contact
these two persons.

<p> &nbsp </p>


<H2> ISIS Table Library </H2>
<p> &nbsp </p>
<p><font size=4>
This library is designed to aid in the sequential reading of formatted
ASCII table files.  It is somewhat forgiving of formatting irregularities
but basically wants to see a file where the records are newline delimited
and where the first record is a header delimiting and naming the columns.
</font></p>
<p> &nbsp </p>

<h3> Keyword Line </h3>

<p><font size=4>
This library supports keywords in a ISIS table file. Users are able to define
their own keywords. The keywords are case sensitive and must begin
with the backslash("\") character with no space between backslash and the
content of a keyword. </br>

<pre>
\catalog = sao 
\date = "Wed Sep 20 09:48:36 1995" 
\ 
|-----ra---|----dec---|---sao---|------v---|----sptype--------| 
|    real  |   real   |   int   |    real  |     char         | 
</pre>
</font></p>
<p> &nbsp </p>


<h3> Table Header </h3>
<p><font size=4>
The header must use the vertical bar ("|") character to mark the
column boundaries and the corresponding positions in subsequent
records should be blank.  A typical file of this sort could look like
the following:

<pre>
|     ra   |    dec   |   sao   |      v   |    sptype        | 
|  double  | double   |   int   |    double|     char         | 
|    unit  |   unit   |   unit  |    unit  |     unit         |  
|    null  |   null   |   null  |    null  |     null         |  
|    scale |   scale  |   scale |    scale |                  |  
|    offset|   offset |         |    offset|                  |  
    2.09708   29.09056     73765    2.06000   B8IVpMnHg          
    2.29458   59.14972     21133    2.27000   F2III-IV           
    6.57083  -42.30611    215093    2.39000   K0III              
   10.12708   56.53722     21609    2.23000   K0IIIa             
   10.89750  -17.98667    147420    2.04000   G9.5IIICH-1        

Dashes can be used in place of the spaces in the header:	


|-----ra---|----dec---|---sao---|------v---|----sptype--------| 
</pre>

and omitting the first vertical bar is forbade. 
</p>

<p><font size=4>
The six header lines should be in the order of column name,
data type, unit, null value, scale, and offset. They can be dropped
from the bottom. But there should at least have two lines to
define column names and data types for correct data conversion.
Data type has three category: integer, double, and
character.
<p> &nbsp </p>


<h3> Comment Line </H3>
<p><font size=4>
Lines beginning with the backslash ("\") character and space are theated
as comment lines. This allows users adding any comments and information
to their talbe.</br>

<pre>
\catalog = sao</br>
\date = "Wed Sep 20 09:48:36 1995"</br>
\<br>
|-----ra---|----dec---|---sao---|------v---|----sptype--------| </br>
|   double |  double  |   int   |    double|     char         | </br>
    2.09708   29.09056     73765    2.06000   B8IVpMnHg         </br>
    2.29458   59.14972     21133    2.27000   F2III-IV          </br> 
    6.57083  -42.30611    215093    2.39000   K0III             </br> 
\ and so on							</br>
   10.12708   56.53722     21609    2.23000   K0IIIa            </br> 
   10.89750  -17.98667    147420    2.04000   G9.5IIICH-1       </br> 
</pre>

would be interpreted exactly the same as the original example.  </br>
<p> &nbsp </p>

<p>
Tables with no header line are not allowed. 
<p> &nbsp </p>



<H2> ISIS Library Functions </H2>

<pre><font size=4>
---


int ifile = isis_open(fname, &ncol) 

char *fname;  	/* table name */
int   ncol;     /* number of column */ 

Open the table file pointed to by fname, parse the header, and
return a pointer to be used in referring to the table. 

The  ifile should return a value larger or equal to zero if
call is sucsessful. This value is equal file reference number.
If ifile returns -2, it indicates there is not enough memory
left for allocate memory resources.


---


int stat = isis_close(ifile)

int   ifile;		/* file reference number */

Close the table file and recycle the memory associated with it.

Stat is the status of executing this subroutine. Zero indicates 
success, while -1 indicates error condition. 



---



int stat = isis_rewind(ifile)

int   ifile;		/* file reference number */

Go back to the top of the file (i.e. just before reading the first record).

Stat can be 0 or -1. Zero means OK while -1 means error condition. 


---


int icol = isis_column(ifile, name)

int   ifile;		/* file reference number */
char *name;		/* given column name */

Find the column which has the given name.

Stat can have -7. This value indicates no such column exist.


---


int stat = isis_colinfo(ifile, icol, &name, &width, &endcol,
		      &dtyp, &unit, &null, &scal, %zero)

int   ifile;		/* file reference number */
int   icol;		/* column number */
char  *name; 		/* column name */
char  *dtyp; 		/* column data type */
char  *unit;		/* column unit */
char  *scal; 		/* column scaling factor  */
char  *zero;		/* column offset */
int   width;		/* column width in bytes */
int   endcol;		/* byte number for a ending column */

Get information about a specific column by number (icol < ncol).
This information includes the column name, its width, the column
it ends on, data type, unit, scaling factor, data offset, and
defined null value for the column.

The column icol is start from 0. The status of the routine are
zero and -1. One indicates OK while another indicates error.


---


int stat = isis_read(ifile, irow)

int   ifile;		/* file reference number */
int   irow;		/* row number */

Read the data record at irow. If irow is smaller than row number currently 
is pointed at, the routine rewinds automatically for IPAC ASCII format 
file. 

The possible status can be the following:
    stat = 0;	 	/* ok */	
    stat = -2;	 	/* no more menory */	
    stat = -4;	 	/* end of file */	
    stat = -5;	 	/* reading error */	


---


char *value = isis_colstr(ifile, icol, &stat)

int   ifile;		/* file reference number */ 
int   icol;		/* column number */
int   stat;		/* process status */

Extract a column value (by column number) from the current record for 
this file.

The possible status:
    stat = 0;    	/* ok */
    stat = -1;   	/* table error */
    stat = -2;   	/* no such file */
    stat = -6;   	/* file not open yet */


---


char *msg = isis_error()

Returns the last error message generated.


---


int stat = isis_convert(val, type, ptr)

char  *val;		/* column content in character string */
int   type;		/* data type */
void  ** ptr;		/* void pointer */

Convert a string to required data type.

The possible status:
    stat = 0;		/* ok */
    stat = -1;	       	/* table error */
    stat = -9;		/* no such type */
    stat = -10;		/* convertion error */


---


int stat = isis_type(ifile, icol)

int ifile;		/* file reference number */
int icol;		/* column number starting from 0 */

Returns the data type for a given column.

The possible status:
    stat = 1;		/* doubel */
    stat = 2;	       	/* integer */
    stat = 3;		/* character */
    stat = -9;		/* no such data type */
    stat = -10;		/* no such column */


---


int stat = isis_scaling(type, scale, offset, inptr, outptr)

int	type;		/* data type */
void	*scale;		/* scaling factor */
void	*offset;	/* data offset */
void	*inptr;		/* input pointer */
void	*outptr;	/* output pointer */

Returns a scaled value if scale and offset values are given.

The possible status:
    stat = 0;		/* ok */
    stat = -1;	       	/* table error */
    stat = -9;		/* no such data type */
    stat = -10;		/* convertion error */
    stat = 4;		/* warning */


---


int stat = isis_keyinfo(ifile, ith, nkey, key, kval)

int	ifile;		/* file reference number */
int	ith;		/* the key index */
int	*nkey;		/* number of keys in a table */
char	key[len];	/* keyword */
char    kval[len];	/* value for a keyword */

For a given key index ith, key(keyword) and contents of key are returned.

The possible status:
    stat = 0;		/* ok */
    stat = -1;	       	/* table error */

---

</pre>

<H2> WRAPPING Table Library </H1>
<p> &nbsp </p>
<p><font size=4>
This wraping library is designed to aid in the sequential reading of ISIS
(IPAC ASCII table and IPAC FIXED LENGTH ASCII table), FITS ASCII table 
and FITS BINARY table. The formats of an ISIS ASCII table should confirm 
to ISIS table convention, while
FITS table files should confirm to the FITS formats.     
</font></p>
<p> &nbsp </p>


<H3> Data Structure </H3>
<p><font size=4>
This library returns data structures for several calls. These structures
save and store file infomation and column infomation. They are defined
as the following:

<pre>
struct tbl_filinfo
{
   int           file_handle;		/* file handle */
   FILE          *fileptr;		/* file pointer */
   int           table_type;		/* table file type */
   long int      nrows;			/* number of rows */
   int           ncols;			/* number of column */
   int           nkeywords;		/* number of keyword */
};

struct tbl_colinfo
{
   int           byte_width;		/* column byte width */
   int           endcol;		/* ending byte for a column */
   char          name[TBL_KEYLEN];	/* column name */ 
   char          data_type[TBL_KEYLEN]; /* data type */
   char          unit[TBL_KEYLEN];	/* data unit */
   char          null_string[TBL_KEYLEN];/*null value string */
   char          scale[TBL_KEYLEN];	/* data scale factor */
   char          offset[TBL_KEYLEN];	/* data offset */
   char          display[TBL_KEYLEN];	/* display format */
};


</pre>
</font></p>


<H2> Table Return Status </H2>
<pre><font size=4>

Every subroutine in this library returns status. These status is
defined as the following:


#define     TBL_OK           0		/* call success */
#define     TBL_ERROR       -1		/* error occure */
#define     TBL_NOMEM       -2		/* not enough memory for aloocation */
#define     TBL_NOFILE      -3		/* no such file */
#define     TBL_EOF         -4		/* end of file */
#define     TBL_RDERR       -5		/* table read error */
#define     TBL_NOTOPN      -6		/* file not open yet */
#define     TBL_NOCOL       -7		/* no such column */ 
#define     TBL_TYPERR      -8		/* no such file type */
#define     TBL_NOTYP       -9		/* no such data type */
#define     TBL_CNVERR     -10		/* convertion error */
#define     TBL_WSCAL      -11		/* convertion warning */
#define     TBL_WARNING      4		/* warning */

</pre>
</font></p>


<H2> Table Wrapping Library Functions </H2>

<pre><font size=4>
---


int ifile = tbl_open(fname, &fileinfo) 

char 		 *fname; 		/* file name */
int 		 ifile; 		/* file reference number */	
struct filinfo   *fileinfo; 		/* structure stores file infomation */

Open the table file pointed to by fname, return a struct pointer to be used 
to retrieval file infomation. 

The possible status:
    ifile > 0;           /* file handle */
    ifile = -1;          /* table error */
    ifile = -2;          /* no memory left */
    ifile = -5;          /* read error */
    ifile = -6;          /* can not open the file */
    ifile = -8;          /* not a proper file type */


---


int stat = tbl_close(ifile)

int   ifile;				/* file reference number */

Close the table file and recycle the memory associated with it.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */


---


int icol = tbl_column(ifile, name)

int   ifile;				/* file reference number */
char  *name;				/* column name */

Find the column number which matches a given column name.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */


---


int stat = tbl_colinfo(ifile, icol, &colinfo)

int   		     	ifile;		/* file reference number */
int			icol;		/* column number */
struct tbl_colinfo  	colinfo;	/* column structure for information */

Get information about a specific column by number (icol < ncol).
Colinfo contains information about the column name, its width, the column
it ends on, data type, unit, scaling factor, data offset, and
defined null value for the column.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */

---





char *value = tbl_colstr(ifile, irow, icol, &stat)

int   	ifile;				/* file reference number */
int	icol;				/* column number */
int	irow;				/* row number */
int	stat;				/* return status */
char	*value;				/* column string value */

Extract a column value based on column and row index. 

The possible status:
    stat = 0;           		/* ok */
    stat = -2;          		/* no memory left */
    stat = -4;          		/* end of file */
    stat = -5;          		/* read error */
    stat = -6;          		/* file not open */


---


int stat = tbl_colval(ifile, irow, icol, type, val(x,i,c))

int    	ifile;				/* file handle */
int    	irow;				/* row number */
int	icol; 				/* column number */
int	type;				/* data type */
double 	valx;				/* returned double value */
int    	vali;				/* return integer value */
char    valc;				/* return character value */

Return column value according to the data type. There are three data types:
double, integer, and character. 

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */
    stat = -6;          		/* file not open */
    stat = -7;          		/* no such column */
    stat = -9;          		/* no such data type */
    stat = -10;          		/* convertion error */
    stat = -11;          		/* convertion warning */
    stat = 4;	          		/* warning */


---


int stat = tbl_type(ifile, icol)

int ifile;				/* file reference number */
int icol;				/* column number */

Returns the data type for a given column.

The possible status:
    stat = 1;           		/* double */
    stat = 2;          			/* integer */
    stat = 3;          			/* character */
    stat = -9;          		/* no such data type */


---


int stat = tbl_keyinfo(ifile, ith, key, kval)

int	ifile;				/* file reference number */
int	ith;				/* keyword index */
char	key[len];			/* keyword */
char	kval[len];			/* value of a keyword */

For given key index ith and file index ifile, key(keyword) and kval(contents 
of key) are returned.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */
    stat = -6;          		/* file not open */


---


int stat = tbl_keyval(ifile, key, &kval, &i)

int	ifile;				/* file refrence number */
int	i;				/* keyword index */
char	key[len];			/* keyword */
char	kval[len];			/* value of a keyword */

This routine retrieval vlaue of a keyword and the index for a keyword.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */
    stat = -6;          		/* file not open */
    stat = -9;          		/* no such data type */


---


int stat = tbl_scale(ifile, icol, type, &scale(x,i,c));

int	ifile;				/* file reference number */
int	icol;				/* column number */
int	type;				/* data type */
double	scalex;				/* return double value */
int	scalei;				/* return integer value */
char	scalec;				/* return character value */

This routine returns scale factor. If offset is not defined for a FITS 
file, a double precision 0 is returned, regardless of data type. If scale  
is not defined for a IPAC file, value 0 is returned in double, integer,
or character, according to the data type.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */
    stat = -9;          		/* no such data type */
    stat = -10;          		/* convertion error */
    stat = 4;	          		/* warning */


---


int stat = tbl_zero(ifile, icol, type, &zero(x,i,c));

int	ifile;				/* file reference number */
int	icol;				/* column index */
int	type;				/* data type */
double	zerox;				/* return double value */
int	zeroi;				/* return integer value */
char	zeroc;				/* return character */

This routine returns offset factor. If offset is not defined for a FITS 
file, a double precision 0 is returned, regardless of data type. If offset
is not defined for a IPAC file, value 0 is returned in double, integer,
or character, according to the data type.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */
    stat = -9;          		/* no such data type */
    stat = -10;          		/* convertion error */
    stat = 4;	          		/* warning */


---


int stat = tbl_fileinfo(ifile, &fileinfo)

int			ifile;		/* file handle */
struct tbl_filinfo	fileinfo;	/* file information structure */

Given a file handle number, routine returns file information.

The possible status:
    stat = 0;           		/* ok */
    stat = -1;          		/* error */


---

</pre>
</html>

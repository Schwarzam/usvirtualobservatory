package edu.harvard.cfa.vo.tapclient.tool;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.List;
import java.util.Set;
import javax.xml.bind.DatatypeConverter;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.MissingOptionException;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.OptionGroup;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.apache.commons.cli.UnrecognizedOptionException;

import edu.harvard.cfa.vo.tapclient.tap.AsyncJob;
import edu.harvard.cfa.vo.tapclient.tap.Error;
import edu.harvard.cfa.vo.tapclient.tap.Result;
import edu.harvard.cfa.vo.tapclient.tap.SyncJob;
import edu.harvard.cfa.vo.tapclient.tap.TapService;
import edu.harvard.cfa.vo.tapclient.util.HttpException;
import edu.harvard.cfa.vo.tapclient.util.ResponseFormatException;
import edu.harvard.cfa.vo.tapclient.vosi.Availability;
import edu.harvard.cfa.vo.tapclient.vosi.Capabilities;
import edu.harvard.cfa.vo.tapclient.vosi.TableSet;

/**
 * A TAP command line interface.
 */
public class TapCli {
    private static final String BASENAME = "edu.harvard.cfa.vo.tapclient.example.TapCli";
    private static final String CMDLINESYNTAX = "cmdLineSyntax";
    private static final String VERSION = "1.0";

    private static Options stopOptions;
    private static Options basicOptions;
    private static Options jobOptions;
    private static Options syncOptions;
    private static Options allOptions;

    private static final Option baseurlOption = OptionBuilder.hasArg(true).withArgName("url").withDescription("TAP service base URL.").withLongOpt("baseurl").create('b');
    private static final Option outputOption = OptionBuilder.hasArg(true).withArgName("file").withDescription("Write output to file instead of stdout.").withLongOpt("output").create('o');
    private static final Option jobidOption = OptionBuilder.hasArg(true).withArgName("string").withDescription("The identifier for the job as generated by the service").withLongOpt("jobid").create('j');
    private static final Option queryOption = OptionBuilder.hasArg(true).withArgName("query").withDescription("The ADQL query.  This option may also be used to specify the query for other values of LANG (e.g. LANG=<some RDBMS-specific SQL variant>) which may be described in the service capabilities.").withLongOpt("query").create('q');
    private static final Option destructionOption = OptionBuilder.hasArg(true).withArgName("timestamp").withDescription("The instant when the job shall be destroyed.  The service may override the requested Destruction Time and substitute a value of its choosing.").withLongOpt("destruction").create('d');
    private static final Option executiondurationOption = OptionBuilder.hasArg(true).withArgName("integer").withDescription("The duration, in seconds, for which a job shall run. An execution duration of 0 implies unlimited execution duration.").withLongOpt("executionduration").create('e');
    private static final Option formatOption = OptionBuilder.hasArg(true).withArgName("format").withDescription("The desired format for the table of results of a query.  A TAP service must support 'votable' as an output format, should support 'csv' and 'tsv' output, and may support other formats.").withLongOpt("format").create('f');
    private static final Option langOption = OptionBuilder.hasArg(true).withArgName("string").withDescription("The query language.  The only value for the LANG parameter a service must support is 'ADQL'.").withLongOpt("lang").create('l');
    private static final Option maxrecOption = OptionBuilder.hasArg(true).withArgName("integer").withDescription("The maximum number of table records (rows) to be returned.  If MAXREC is not specified in a query, the service may apply a default value or may set no limit.").withLongOpt("maxrec").create('m');
    private static final Option phaseOption = OptionBuilder.hasArg(true).withArgName("{run|abort}").withDescription("Execution phase.  The job may be started by specifying 'run' as the argument or aborted by specifying 'abort' as the argument.").withLongOpt("phase").create('p');
    private static final Option runidOption = OptionBuilder.hasArg(true).withArgName("string").withDescription("The RunId represents an identifier that the job creator uses to identify the job.  Note that this is distinct from the Job Identifier that the service itself assigns to each job.").withLongOpt("runid").create('r');
    private static final Option uploadOption = OptionBuilder.hasArgs().withArgName("tablename,uri").withDescription("Upload tablename,uri pair.  This option may be specified multiple time to upload multiple tables.  Table names must be legal ADQL table names. URIs maybe be simple URLs (e.g. with a URI scheme of http) or URIs (e.g. with a URI scheme of vos or param) that must be resolved to give the location of the table content.").withLongOpt("upload").create('u');
    private static final Option helpOption = OptionBuilder.withDescription("Display usage information").withLongOpt("help").create('?');
    private static final Option versionOption = OptionBuilder.withDescription("Display version information").withLongOpt("version").create('V');
    private static final Option verboseOption = OptionBuilder.withDescription("Print extra information").withLongOpt("verbose").create('v');

    /**
     * Returns the options which stop further processing of the command line arguments, such as --help or --verison.
     * @return the options which stop further processing
     */
    protected static Options getStopOptions() {
	if (stopOptions == null) {
	    stopOptions = new Options();
	    stopOptions.addOption(helpOption);
	    stopOptions.addOption(versionOption);
	    stopOptions.addOption(verboseOption);
	} 
	return stopOptions;
    }

    /**
     * Returns the basic options for the various subcommands.
     * @return the basic options
     */
    protected static Options getBasicOptions() {
	if (basicOptions == null) {
	    basicOptions = new Options();

	    basicOptions.addOption(baseurlOption);
	    basicOptions.addOption(helpOption);
	    basicOptions.addOption(versionOption);
	    basicOptions.addOption(outputOption);
	    basicOptions.addOption(verboseOption);
	} 
	return basicOptions;
    }

    /**
     * Returns the options for job specific subcommands such as results or error.
     * @return the options for job specific subcommands
     */
    protected static Options getJobOptions() {
	if (jobOptions == null) {
	    jobOptions = new Options();
	    jobOptions.addOption(baseurlOption);
	    jobOptions.addOption(outputOption);
	    jobOptions.addOption(jobidOption);
	    jobOptions.addOption(helpOption);
	    jobOptions.addOption(versionOption);
	    jobOptions.addOption(verboseOption);
	} 
	return jobOptions;
    }

    /**
     * Returns the options for the sync subcommand.
     * @return the sync specific options
     */
    protected static Options getSyncOptions() {
	if (syncOptions == null) {
	    syncOptions = new Options();
	    syncOptions.addOption(baseurlOption);
	    syncOptions.addOption(outputOption);
	    syncOptions.addOption(queryOption);
	    syncOptions.addOption(formatOption);
	    syncOptions.addOption(langOption);
	    syncOptions.addOption(maxrecOption);
	    syncOptions.addOption(uploadOption);
	    syncOptions.addOption(helpOption);
	    syncOptions.addOption(versionOption);
	    syncOptions.addOption(verboseOption);
	}
	return syncOptions;
    }

    /**
     * Returns all the options.  For use by the async subcommand.
     * @return all the options
     */
    protected static Options getAllOptions() {
	if (allOptions == null) {
	    allOptions = new Options();
	    allOptions.addOption(baseurlOption);
	    allOptions.addOption(outputOption);
	    allOptions.addOption(jobidOption);
	    allOptions.addOption(queryOption);
	    allOptions.addOption(destructionOption);
	    allOptions.addOption(executiondurationOption);
	    allOptions.addOption(formatOption);
	    allOptions.addOption(langOption);
	    allOptions.addOption(maxrecOption);
	    allOptions.addOption(phaseOption);
	    allOptions.addOption(runidOption);
	    allOptions.addOption(uploadOption);
	    allOptions.addOption(helpOption);
	    allOptions.addOption(versionOption);
	    allOptions.addOption(verboseOption);
	}
	return allOptions;
    }

    /**
     * The subcommands
     */
    protected enum SubCommand { 
	/**
	 * Access the <baseurl>/availability endpoint
	 */
	AVAILABILITY ("Access TAP <baseurl>/availability endpoint"),
	/**
	 * Access the <baseurl>/capabilities endpoint
	 */
	    CAPABILITIES ("Access TAP <baseurl>/capabilities endpoint"),
	/**
	 * Access the <baseurl>/tables endpoint
	 */
	    TABLES ("Access TAP <baseurl>/tables endpoint"),
	/**
	 * Access the job list at the <baseurl>/async endpoint
	 */
	    JOBS ("Access TAP <baseurl>/async endpoint"),
	/**
	 * Access the <baseurl>/sync endpoint
	 */
	    SYNC ("Access TAP <baseurl>/sync endpoint"),
	/**
	 * Access the <baseurl>/async endpoint for job creation, modification, retrieval, or execution.
	 */
	    ASYNC ("Access TAP <baseurl>/async endpoint"),
	/**
	 * Access the <baseurl>/async/<jobid>/results endpoint
	 */
	    RESULTS ("Access TAP <baseurl>/async/<jobid>/results endpoint"),
	/**
	 * Access the <baseurl>/async/<jobid>/error endpoint
	 */
	    ERROR ("Access TAP <baseurl>/async/<jobid>/error endpoint");
	
	private final String description;
	SubCommand(String description) { this.description = description; }
	public String description() { return description; }
	public String toString() { return super.toString().toLowerCase(); }

    };

    /**
     * Parse the command line arguments stopping at the first non-option.
     * @param options the options to look for
     * @param args the command line arguments
     * @return the parsed command line
     * @throws ParseException if an error occurs parsing the options
     * @see parseCommandLine(Options,String[],boolean)
     */
    protected static CommandLine parseCommandLine(Options options, String[] args) throws ParseException {
	return parseCommandLine(options, args, true);
    }

    /**
     * Parse the command line arguments stopping at the first non-option if stopAtNonOption is true.
     * @param options the options to look for
     * @param args the command line arguments
     * @param stopAtNonOption stops at the first non-option if true.
     * @return the parsed command line
     * @throws ParseException if an error occurs parsing the options
     * @see parseCommandLine(Options,String[],boolean)
     */
    protected static CommandLine parseCommandLine(Options options, String[] args, boolean stopAtNonOption) throws ParseException {
	CommandLine commandLine = new PosixParser().parse(options, args, stopAtNonOption);

	if (commandLine.hasOption(verboseOption.getOpt())) {
	    for (Object obj: options.getOptions()) {
		System.err.println((Option) obj);
	    }
	    for (String arg: args) {
		System.err.println(arg);
	    }
	}

	return commandLine;
    }

    /**
     * Checks if the command line contains a stop option, such as helpOption or versionOption.  If it does, printHelp or printVersion is called. 
     * @return true if the commandline contains a stop option, such as helpOption or versionOption
     */
    protected static boolean checkStopOption(CommandLine commandLine, SubCommand subCommand, Options options) {
	boolean isStopOption = false;
	if (commandLine.hasOption(helpOption.getOpt())) {
	    isStopOption = true;
	    printHelp(System.out, subCommand, BASENAME+" "+(subCommand != null ? subCommand : "<subcommand>"), options);
	} else if (commandLine.hasOption(versionOption.getOpt())) {
	    isStopOption = true;
	    printVersion(System.out, BASENAME, VERSION);
	} 
	return isStopOption;
    }

    /**
     * Returns all of the SubCommand represented as Options
     */
    private static Options getSubCommandsAsOptions() {
	Options subCommandsAsOptions = new Options();
	for (SubCommand subCommand: SubCommand.values()) {
	    subCommandsAsOptions.addOption(OptionBuilder.isRequired(true).withDescription(subCommand.description()).create(subCommand.toString()));
	}
	return subCommandsAsOptions;
    }

    /**
     * @arg printStream the PrintStream used for output
     * @arg subCommand the subcommand in effect when this method was called.  This value is null if --help was the first argument.
     * @arg cmdLineSyntax the command line syntax
     * @arg options the options
     */
    protected static void printHelp(PrintStream printStream, SubCommand subCommand, String cmdLineSyntax, Options options) {
	PrintWriter printWriter = new PrintWriter(printStream, true);

	HelpFormatter helpFormatter = new HelpFormatter();
	if (subCommand != null) {
	    helpFormatter.printUsage(printWriter, helpFormatter.getWidth(), cmdLineSyntax);
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "");
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "Available options:");
	    helpFormatter.printOptions(printWriter, helpFormatter.getWidth(), options, helpFormatter.getLeftPadding(), helpFormatter.getDescPadding());
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "");
	} else {
	    helpFormatter.setOptPrefix("");
	    helpFormatter.printUsage(printWriter, helpFormatter.getWidth(), cmdLineSyntax);
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "");
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "Available subcommands: ");
	    helpFormatter.printOptions(printWriter, helpFormatter.getWidth(), getSubCommandsAsOptions(), helpFormatter.getLeftPadding(), helpFormatter.getDescPadding());
	
	    helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), "");
	}
    }

    /**
     * @arg printStream the PrintStream used for output
     * @arg baseName the base name of this application
     * @arg version the version of this application
     */
    protected static void printVersion(PrintStream printStream, String baseName, String version) {
	PrintWriter printWriter = new PrintWriter(System.out, true);
	HelpFormatter helpFormatter = new HelpFormatter();
	helpFormatter.printWrapped(printWriter, helpFormatter.getWidth(), baseName+" (TAP Client API 1.0) "+version);
    }

    /**
     * Get a PrintStream for the outputOption specified in the command line
     * @args commandLine the commandLine
     * @return a PrintStream for the specified outputOption.  Note that if no outputOption is specified System.out is used.
     */
    protected static PrintStream getOutputOptionPrintStream(CommandLine commandLine) throws FileNotFoundException, UnsupportedEncodingException {
	return commandLine.hasOption(outputOption.getOpt()) ? new PrintStream(outputOption.getValue(), "UTF-8") : System.out;
    }

    /**
     * Access the <baseurl>/availability endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doAvailability(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    Availability availability = tapService.getAvailability();
	    availability.list(output);
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the <baseurl>/capabilities endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doCapabilities(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    Capabilities capabilities = tapService.getCapabilities();
	    capabilities.list(output);
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the <baseurl>/tables endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doTables(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    TableSet tableSet = tapService.getTableSet();
	    tableSet.list(output);
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the job list at the <baseurl>/async endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doJobs(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    List<AsyncJob> jobs = tapService.getJobs();
	    for (AsyncJob job: jobs) {
		job.list(output);
	    }
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the job results at the <baseurl>/async/<jobid>/results endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doResults(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    AsyncJob asyncJob = new AsyncJob(tapService, commandLine.getOptionValue(jobidOption.getOpt()));
	    asyncJob.synchronize();
	    Set<Result> results = asyncJob.getResults();
	    Iterator<Result> iterator = results.iterator();
	    while (iterator.hasNext()) {
		iterator.next().list(output);
	    }
	} finally {
	    output.flush();
	    output.close();
	}
    }
    
    /**
     * Access the job error document at the <baseurl>/async/<jobid>/error endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doError(CommandLine commandLine) throws HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    AsyncJob asyncJob = new AsyncJob(tapService, commandLine.getOptionValue(jobidOption.getOpt()));
	    asyncJob.synchronize();
	    Error error = asyncJob.getError();
	    error.list(output);
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the asynchronous query <baseurl>/async or <baseurl>/async/<jobid> endpoint and write out the server response.  This method allows for query creation, modification, retrieval, and execution.
     * @arg commandLine the command line
     * @throws ParseException if the phase or upload parameters have syntax errors
     * @throws URISyntaxException if the upload parameter has a URI syntax error
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws ResponseFormatException if an error occurred parsing the expected reponse format
     * @throws IOException if an IO error occurred while handling the response
     * @see doResults
     * @see doError
     */
     protected static void doAsync(CommandLine commandLine) throws ParseException, URISyntaxException, HttpException, ResponseFormatException, IOException {
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    AsyncJob asyncJob = null;
	    if (commandLine.hasOption(jobidOption.getOpt())) {
		asyncJob = new AsyncJob(tapService, commandLine.getOptionValue(jobidOption.getOpt()));
	    } else {
		asyncJob = new AsyncJob(tapService);
	    }
	    
	    if (commandLine.hasOption(destructionOption.getOpt())) 
		asyncJob.setDestruction(DatatypeConverter.parseDateTime(commandLine.getOptionValue(destructionOption.getOpt())));

	    if (commandLine.hasOption(executiondurationOption.getOpt())) 
		asyncJob.setExecutionDuration(Integer.parseInt(commandLine.getOptionValue(executiondurationOption.getOpt())));

	    if (commandLine.hasOption(formatOption.getOpt())) 
		asyncJob.setFormat(commandLine.getOptionValue(formatOption.getOpt()));

	    if (commandLine.hasOption(langOption.getOpt())) 
		asyncJob.setLang(commandLine.getOptionValue(langOption.getOpt()));

	    if (commandLine.hasOption(maxrecOption.getOpt())) 
		asyncJob.setParameter("MAXREC", commandLine.getOptionValue(maxrecOption.getOpt()));

	    if (commandLine.hasOption("parameter")) {
		for (String value: commandLine.getOptionValues("parameter")) {
		    String[] nameValue = value.split("=");
		    if (nameValue.length != 2)
			throw new ParseException("Bad argument for option: p");
		    asyncJob.setParameter(nameValue[0], nameValue[1]);
		}
	    }

	    if (commandLine.hasOption(queryOption.getOpt())) 
		asyncJob.setQuery(commandLine.getOptionValue(queryOption.getOpt()));

	    if (commandLine.hasOption(runidOption.getOpt())) 
		asyncJob.setParameter("RUNID", commandLine.getOptionValue(runidOption.getOpt()));

	    if (commandLine.hasOption(uploadOption.getOpt())) {
		String[] optionValues = commandLine.getOptionValues(uploadOption.getOpt());
		for (String optionValue: optionValues) {
		    String[] nameValue = optionValue.split(",");
		    if (nameValue.length != 2)
			throw new ParseException("Bad argument for option: u");
		    asyncJob.addInlineUpload(nameValue[0], new URI(nameValue[1]));
		}
	    }
	    
	    if (commandLine.hasOption(phaseOption.getOpt())) {
		String value = commandLine.getOptionValue(phaseOption.getOpt());
		if ("RUN".equals(value.toUpperCase())) {
		    asyncJob.run();
		} else if ("ABORT".equals(value.toUpperCase())) {
		    asyncJob.abort();
		} else {
		    throw new ParseException("Bad argument for option: p");
		}
	    } else {
		asyncJob.synchronize();
	    }
	    
	    asyncJob.list(output);
	} finally {
	    output.flush();
	    output.close();
	}
    }

    /**
     * Access the synchronous query <baseurl>/sync endpoint and write out the server response.
     * @arg commandLine the command line
     * @throws ParseException if the phase or upload parameters have syntax errors
     * @throws URISyntaxException if the upload parameter has a URI syntax error
     * @throws HttpException if the server responded with an unexpected HTTP Status Code
     * @throws IOException if an IO error occurred while handling the response
     */
    protected static void doSync(CommandLine commandLine) throws ParseException, URISyntaxException, HttpException, IOException {
	InputStream input = null;
	PrintStream output = getOutputOptionPrintStream(commandLine);
	try {
	    TapService tapService = new TapService(commandLine.getOptionValue(baseurlOption.getOpt()));
	    SyncJob syncJob = new SyncJob(tapService);
	    
	    // if (commandLine.hasOption(formatOption.getOpt())) 
	    syncJob.setFormat(commandLine.getOptionValue(formatOption.getOpt(), "votable"));

	    // if (commandLine.hasOption(langOption.getOpt())) 
	    syncJob.setLang(commandLine.getOptionValue(langOption.getOpt(), "ADQL"));

	    if (commandLine.hasOption(maxrecOption.getOpt())) 
		syncJob.setParameter("MAXREC", commandLine.getOptionValue(maxrecOption.getOpt()));

	    if (commandLine.hasOption("parameter")) {
		for (String value: commandLine.getOptionValues("parameter")) {
		    String[] nameValue = value.split("=");
		    if (nameValue.length != 2)
			throw new ParseException("Bad argument for option: p");
		    syncJob.setParameter(nameValue[0], nameValue[1]);
		}
	    }

	    if (commandLine.hasOption(queryOption.getOpt())) 
		syncJob.setQuery(commandLine.getOptionValue(queryOption.getOpt()));

	    if (commandLine.hasOption(runidOption.getOpt())) 
		syncJob.setParameter("RUNID", commandLine.getOptionValue(runidOption.getOpt()));

	    if (commandLine.hasOption(uploadOption.getOpt())) {
		String[] optionValues = commandLine.getOptionValues(uploadOption.getOpt());
		for (String optionValue: optionValues) {
		    String[] nameValue = optionValue.split(",");
		    if (nameValue.length != 2)
			throw new ParseException("Bad argument for option: u");
		    syncJob.addInlineUpload(nameValue[0], new URI(nameValue[1]));
		}
	    }
	    
	    input = new BufferedInputStream(syncJob.run());
	    int b = -1;
	    while ((b = input.read()) != -1) {
		output.write(b);
	    }
	} finally {
	    output.flush();
	    output.close();

	    input.close();
	}
    }

    public static void main(String[] args) {
	int exitStatus = 0;
	
	CommandLine commandLine = null;
	try {
	    SubCommand subCommand = null;

	    // <command> <subcommand>  continue
	    // <command> <other>       throw new Exception
	    // <command> --help        System.exit(0)
	    // <command> --version     System.exit(0)
	    // <command> --<other>     throw new Exception
	    try {
		subCommand = SubCommand.valueOf(args[0].toUpperCase());
	    } catch (ArrayIndexOutOfBoundsException ex) {
		throw new ParseException ("Missing required command");
	    } catch (IllegalArgumentException ex) {
		if (args[0].charAt(0) == '-') {
		    try {
			commandLine = parseCommandLine(getStopOptions(), args, false); 
		    } catch (UnrecognizedOptionException uoe) {
			throw new ParseException ("Missing required command");
		    } 

		    if (checkStopOption(commandLine, null, new Options()))
			System.exit(0);
		    
		    if (commandLine.hasOption(verboseOption.getOpt())) {
			throw new ParseException ("Missing required command");
		    }
		    // Handler --<not_help_or_version

		} else {
		    throw new ParseException("Unknown subcommand: "+args[0]);
		}
	    }

	    String[] subArgs = Arrays.copyOfRange(args, 1, args.length);
	    commandLine = null;
	    switch (subCommand) {
	    case AVAILABILITY:
		commandLine = parseCommandLine(getBasicOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getBasicOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt())) 
		    throw new MissingOptionException(Collections.singletonList(baseurlOption.getOpt()));
		doAvailability(commandLine);
		break;

	    case CAPABILITIES:
		commandLine = parseCommandLine(getBasicOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getBasicOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt())) 
		    throw new MissingOptionException(Collections.singletonList(baseurlOption.getOpt()));
		doCapabilities(commandLine);
		break;

	    case TABLES:
		commandLine = parseCommandLine(getBasicOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getBasicOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt())) 
		    throw new MissingOptionException(Collections.singletonList(baseurlOption.getOpt()));
		doTables(commandLine);
		break;

	    case JOBS:
		commandLine = parseCommandLine(getBasicOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getBasicOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt())) 
		    throw new MissingOptionException(Collections.singletonList(baseurlOption.getOpt()));
		doJobs(commandLine);
		break;

	    case RESULTS:
		commandLine = parseCommandLine(getJobOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getJobOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt()) || ! commandLine.hasOption(jobidOption.getOpt())) {
		    List<String> missing = new ArrayList<String>();
		    if (! commandLine.hasOption(baseurlOption.getOpt())) {
			missing.add(baseurlOption.getOpt());
		    }
		    if (! commandLine.hasOption(jobidOption.getOpt())) {
			missing.add(jobidOption.getOpt());
		    }
		    throw new MissingOptionException(missing);
		}
		doResults(commandLine);
		break;

	    case ERROR:
		commandLine = parseCommandLine(getJobOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getJobOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt()) || ! commandLine.hasOption(jobidOption.getOpt())) {
		    List<String> missing = new ArrayList<String>();
		    if (! commandLine.hasOption(baseurlOption.getOpt())) {
			missing.add(baseurlOption.getOpt());
		    }
		    if (! commandLine.hasOption(jobidOption.getOpt())) {
			missing.add(jobidOption.getOpt());
		    }
		    throw new MissingOptionException(missing);
		}
		doError(commandLine);
		break;
		
	    case ASYNC:
		commandLine = parseCommandLine(getAllOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getAllOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt())) 
		    throw new MissingOptionException(Collections.singletonList(baseurlOption.getOpt()));
		doAsync(commandLine);
		break;

	    case SYNC:
		commandLine = parseCommandLine(getSyncOptions(), subArgs);
		if (checkStopOption(commandLine, subCommand, getSyncOptions()))
		    System.exit(0);
		if (! commandLine.hasOption(baseurlOption.getOpt()) || ! commandLine.hasOption(queryOption.getOpt())) {
		    List<String> missing = new ArrayList<String>();
		    if (! commandLine.hasOption(baseurlOption.getOpt())) {
			missing.add(baseurlOption.getOpt());
		    }
		    if (! commandLine.hasOption(queryOption.getOpt())) {
			missing.add(queryOption.getOpt());
		    }
		    throw new MissingOptionException(missing);
		}
		doSync(commandLine);
		break;

	    default:
		throw new ParseException("Unsupported subcommand: "+subCommand);
	    }
	} catch (ParseException ex) {
	    String message = ex.getMessage();
	    if (message != null && message.length() > 0) {
		System.err.println(message);
	    } else {
		System.err.println("An error occurred");
	    }
	    System.err.println("Type '"+BASENAME+" --help' for usage");
	    if (commandLine != null && commandLine.hasOption(verboseOption.getOpt())) {
		ex.printStackTrace(System.err);
	    }
	} catch (HttpException ex) {
	    String message = ex.getMessage();
	    if (message != null && message.length() > 0) {
		System.err.println(message);
	    } else {
		System.err.println("An error occurred");
	    }
	    if (commandLine != null && commandLine.hasOption(verboseOption.getOpt())) {
		String content = ex.getContent();
		if (content != null && !content.isEmpty())
		    System.err.println(ex.getContent());
		ex.printStackTrace(System.err);
	    }
	} catch (Throwable ex) {
	    String message = ex.getMessage();
	    if (message != null && message.length() > 0) {
		System.err.println(message);
	    } else {
		System.err.println("An error occurred");
	    }
	    if (commandLine != null && commandLine.hasOption(verboseOption.getOpt())) {
		ex.printStackTrace(System.err);
	    }
	}

	System.exit(exitStatus);
    }
} 
